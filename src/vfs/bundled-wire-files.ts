// Auto-generated wire file bundle
// Run: npx tsx scripts/bundle-wire-files.ts

export const WIRE_FILES: Record<string, string> = {
  "wire/adder16.wire": "; 16-bit Adder\n; Adds two 16-bit numbers with carry-in, produces sum and carry-out\n;\n; Implementation: Chain two 8-bit adders\n;   - Low byte: adder8(a[0:7], b[0:7], cin)\n;   - High byte: adder8(a[8:15], b[8:15], carry_from_low)\n;   - Final sum: concat(high_sum, low_sum)\n\nmodule adder16(a:16, b:16, cin) -> (sum:16, cout):\n  ; Add low bytes (bits 0-7) with carry-in\n  low_result = adder8(a[0:7], b[0:7], cin)\n  low_sum = low_result.sum\n  low_carry = low_result.cout\n\n  ; Add high bytes (bits 8-15) with carry from low byte\n  high_result = adder8(a[8:15], b[8:15], low_carry)\n  high_sum = high_result.sum\n  high_carry = high_result.cout\n\n  ; Concatenate high and low sums (high byte first)\n  sum = concat(high_sum, low_sum)\n\n  ; Final carry out\n  cout = high_carry\n",
  "wire/addr_decode.wire": "; Address Decoder\n; Decodes 16-bit address to select memory regions\n;\n; Memory Map:\n;   $0000-$00FF  Zero Page RAM (256 bytes)\n;   $0100-$01FF  Stack RAM (256 bytes)\n;   $0200-$3FFF  General RAM (~16KB)\n;   $4000-$7FFF  [Reserved/Expansion]\n;   $8000-$800F  I/O Registers\n;   $C000-$FFFF  ROM (16KB)\n\nmodule addr_decode(addr:16) -> (sel_zp, sel_stack, sel_ram, sel_io, sel_rom):\n  ; Individual address bits (using bracket notation which works)\n  a15 = addr[15]\n  a14 = addr[14]\n  a13 = addr[13]\n  a12 = addr[12]\n  a11 = addr[11]\n  a10 = addr[10]\n  a9 = addr[9]\n  a8 = addr[8]\n\n  ; Check if high byte is zero (for ZP detection)\n  ; All of a15..a8 must be 0\n  hi_any = or(a15, or(a14, or(a13, or(a12, or(a11, or(a10, or(a9, a8)))))))\n  hi_is_00 = not(hi_any)\n\n  ; Check if high byte is $01 (for stack detection)\n  ; a8=1, all others 0\n  hi_others = or(a15, or(a14, or(a13, or(a12, or(a11, or(a10, a9))))))\n  hi_is_01 = and(not(hi_others), a8)\n\n  ; Zero Page: $0000-$00FF (high byte = $00)\n  sel_zp = hi_is_00\n\n  ; Stack: $0100-$01FF (high byte = $01)\n  sel_stack = hi_is_01\n\n  ; ROM: $C000-$FFFF (A15=1 AND A14=1)\n  sel_rom = and(a15, a14)\n\n  ; I/O: $8000-$80FF (high byte = $80)\n  ; A15=1, A14=0, A13=0, A12=0, A11=0, A10=0, A9=0, A8=0\n  not_a14 = not(a14)\n  not_a13 = not(a13)\n  not_a12 = not(a12)\n  not_a11 = not(a11)\n  not_a10 = not(a10)\n  not_a9 = not(a9)\n  not_a8 = not(a8)\n  hi_is_80 = and(a15, and(not_a14, and(not_a13, and(not_a12, and(not_a11, and(not_a10, and(not_a9, not_a8)))))))\n  sel_io = hi_is_80\n\n  ; General RAM: $0200-$3FFF (A15=0, A14=0, but not ZP or Stack)\n  not_a15 = not(a15)\n  low_region = and(not_a15, not_a14)\n  not_zp_or_stack = nor(sel_zp, sel_stack)\n  sel_ram = and(low_region, not_zp_or_stack)\n",
  "wire/alu.wire": "; Simple 4-bit ALU\n; Operations: 000=ADD, 001=SUB, 010=AND, 011=OR, 100=XOR\n; Outputs: result, zero flag, carry flag\n\nmodule alu4(a:4, b:4, op:3) -> (result:4, zero, carry):\n  ; Compute all operations\n  add_result = adder4(a, b, 0)\n  sub_result = adder4(a, not4(b), 1)\n  and_result = and4(a, b)\n  or_result = or4(a, b)\n  xor_result = xor4(a, b)\n\n  ; Select result based on op[0:1]\n  mux01 = mux4(op[0], add_result.sum, sub_result.sum)\n  mux23 = mux4(op[0], and_result, or_result)\n  base_result = mux4(op[1], mux01, mux23)\n\n  ; Special case for XOR when op[2]=1\n  result = mux4(op[2], base_result, xor_result)\n\n  ; Flags\n  zero = nor(nor(result[0], result[1]), nor(result[2], result[3]))\n  carry = mux(op[0], add_result.cout, sub_result.cout)\n",
  "wire/alu8.wire": "; 8-bit ALU for Wire CPU\n; Operations: 000=ADD, 001=SUB, 010=AND, 011=OR, 100=XOR\n;\n; Inputs:\n;   a:8    - first operand\n;   b:8    - second operand\n;   op:3   - operation select\n;   cin    - carry in (used for ADC/SBC)\n;\n; Outputs:\n;   result:8 - operation result\n;   z        - Zero flag (result == 0)\n;   n        - Negative flag (result bit 7, sign bit)\n;   cout     - Carry flag (carry/borrow out from ADD/SUB)\n;   vout     - Overflow flag (signed overflow for ADD/SUB)\n\nmodule alu8(a:8, b:8, op:3, cin) -> (result:8, z, n, cout, vout):\n  ; ========================================\n  ; Compute all operations in parallel\n  ; ========================================\n\n  ; ADD: a + b + cin\n  add_result = adder8(a, b, cin)\n\n  ; SUB: a - b - !cin = a + ~b + cin\n  ; For subtraction, we invert b and use cin as borrow-in\n  ; When cin=1 (no borrow), we get a - b\n  ; When cin=0 (borrow in), we get a - b - 1\n  not_b = not8(b)\n  sub_result = adder8(a, not_b, cin)\n\n  ; Logical operations (don't use carry)\n  and_result = and8(a, b)\n  or_result = or8(a, b)\n  xor_result = xor8(a, b)\n\n  ; ========================================\n  ; Select result based on op\n  ; ========================================\n  ; op: 000=ADD, 001=SUB, 010=AND, 011=OR, 100=XOR\n\n  ; First level mux: op[0] selects within pairs\n  ; mux_arith: op[0]=0 -> ADD, op[0]=1 -> SUB\n  mux_arith = mux8(add_result.sum, sub_result.sum, op[0])\n\n  ; mux_logic1: op[0]=0 -> AND, op[0]=1 -> OR\n  mux_logic1 = mux8(and_result, or_result, op[0])\n\n  ; Second level mux: op[1] selects between arithmetic and logic1\n  mux_level2 = mux8(mux_arith, mux_logic1, op[1])\n\n  ; Final mux: op[2]=1 selects XOR\n  result = mux8(mux_level2, xor_result, op[2])\n\n  ; ========================================\n  ; Flag generation\n  ; ========================================\n\n  ; Zero flag: result == 0\n  ; Use NOR tree to detect all zeros\n  ; Group bits into pairs, NOR each pair, then AND results\n  nz01 = or(result[0], result[1])\n  nz23 = or(result[2], result[3])\n  nz45 = or(result[4], result[5])\n  nz67 = or(result[6], result[7])\n  nz0123 = or(nz01, nz23)\n  nz4567 = or(nz45, nz67)\n  any_set = or(nz0123, nz4567)\n  z = not(any_set)\n\n  ; Negative flag: bit 7 of result (sign bit in two's complement)\n  n = result[7]\n\n  ; Carry flag: carry out from ADD or inverted borrow from SUB\n  ; For ADD: direct carry out\n  ; For SUB: carry out (no borrow when cout=1)\n  ; Select based on op[0] (0=ADD, 1=SUB)\n  cout = mux(add_result.cout, sub_result.cout, op[0])\n\n  ; Overflow flag: signed overflow for ADD/SUB\n  ; V = 1 when two operands of same sign produce result of different sign\n  ; For ADD: V = (a[7] == b[7]) && (a[7] != result[7])\n  ; For SUB: V = (a[7] != b[7]) && (a[7] != result[7])\n  ;\n  ; ADD overflow: positive + positive = negative, or negative + negative = positive\n  ; SUB overflow: positive - negative = negative, or negative - positive = positive\n\n  ; For ADD: signs are same, but result sign differs from a\n  add_same_sign = xnor(a[7], b[7])              ; 1 if a and b have same sign\n  add_result_diff = xor(a[7], add_result.sum[7]) ; 1 if result has different sign than a\n  v_add = and(add_same_sign, add_result_diff)\n\n  ; For SUB: signs are different (a vs b), but result sign differs from a\n  sub_diff_sign = xor(a[7], b[7])               ; 1 if a and b have different signs\n  sub_result_diff = xor(a[7], sub_result.sum[7]) ; 1 if result has different sign than a\n  v_sub = and(sub_diff_sign, sub_result_diff)\n\n  ; Select overflow based on operation (only valid for ADD/SUB)\n  vout = mux(v_add, v_sub, op[0])\n",
  "wire/alu_test.wire": "; ALU Test Harness - cycles through operations on each clock\n; Demonstrates all ALU operations with fixed test values\n\nmodule alu_test(clk) -> (result:4, zero, carry, op:3):\n  ; Use a 3-bit counter for operation selection\n  op = counter3(1, clk)\n\n  ; Fixed test inputs (a=5, b=3)\n  a = concat(0, 1, 0, 1)  ; 5 = 0b0101\n  b = concat(0, 0, 1, 1)  ; 3 = 0b0011\n\n  ; Run the ALU\n  alu_out = alu4(a, b, op)\n  result = alu_out.result\n  zero = alu_out.zero\n  carry = alu_out.carry\n\n; 3-bit counter for cycling through operations\nmodule counter3(en, clk) -> q:3:\n  next = adder3(q, 1, 0)\n  q = dff3(next.sum, clk)\n\n; 3-bit adder\nmodule adder3(a:3, b:3, cin) -> (sum:3, cout):\n  ha0 = full_adder(a[0], b[0], cin)\n  s0 = ha0.sum\n  c0 = ha0.cout\n\n  ha1 = full_adder(a[1], b[1], c0)\n  s1 = ha1.sum\n  c1 = ha1.cout\n\n  ha2 = full_adder(a[2], b[2], c1)\n  s2 = ha2.sum\n  cout = ha2.cout\n\n  sum = concat(s2, s1, s0)\n\n; 3-bit D flip-flop\nmodule dff3(d:3, clk) -> q:3:\n  q0 = dff(d[0], clk)\n  q1 = dff(d[1], clk)\n  q2 = dff(d[2], clk)\n  q = concat(q2, q1, q0)\n",
  "wire/arithmetic.wire": "; Wire Standard Library - Arithmetic Modules\n; Depends on gates.wire\n\n; Half adder - adds two 1-bit numbers\n; sum = a XOR b, carry = a AND b\nmodule half_adder(a, b) -> (sum, carry):\n  sum = xor(a, b)\n  carry = and(a, b)\n\n; Full adder - adds two 1-bit numbers with carry in\n; sum = a XOR b XOR cin\n; cout = (a AND b) OR (cin AND (a XOR b))\nmodule full_adder(a, b, cin) -> (sum, cout):\n  ab_xor = xor(a, b)\n  sum = xor(ab_xor, cin)\n  ab_and = and(a, b)\n  cin_ab = and(cin, ab_xor)\n  cout = or(ab_and, cin_ab)\n\n; 4-bit ripple carry adder\nmodule adder4(a:4, b:4, cin) -> (sum:4, cout):\n  ; Bit 0\n  ha0 = full_adder(a[0], b[0], cin)\n  s0 = ha0.sum\n  c0 = ha0.cout\n\n  ; Bit 1\n  ha1 = full_adder(a[1], b[1], c0)\n  s1 = ha1.sum\n  c1 = ha1.cout\n\n  ; Bit 2\n  ha2 = full_adder(a[2], b[2], c1)\n  s2 = ha2.sum\n  c2 = ha2.cout\n\n  ; Bit 3\n  ha3 = full_adder(a[3], b[3], c2)\n  s3 = ha3.sum\n  cout = ha3.cout\n\n  ; Concatenate sum bits (high to low)\n  sum = concat(s3, s2, s1, s0)\n\n; 8-bit ripple carry adder\nmodule adder8(a:8, b:8, cin) -> (sum:8, cout):\n  ; Bit 0\n  ha0 = full_adder(a[0], b[0], cin)\n  s0 = ha0.sum\n  c0 = ha0.cout\n\n  ; Bit 1\n  ha1 = full_adder(a[1], b[1], c0)\n  s1 = ha1.sum\n  c1 = ha1.cout\n\n  ; Bit 2\n  ha2 = full_adder(a[2], b[2], c1)\n  s2 = ha2.sum\n  c2 = ha2.cout\n\n  ; Bit 3\n  ha3 = full_adder(a[3], b[3], c2)\n  s3 = ha3.sum\n  c3 = ha3.cout\n\n  ; Bit 4\n  ha4 = full_adder(a[4], b[4], c3)\n  s4 = ha4.sum\n  c4 = ha4.cout\n\n  ; Bit 5\n  ha5 = full_adder(a[5], b[5], c4)\n  s5 = ha5.sum\n  c5 = ha5.cout\n\n  ; Bit 6\n  ha6 = full_adder(a[6], b[6], c5)\n  s6 = ha6.sum\n  c6 = ha6.cout\n\n  ; Bit 7\n  ha7 = full_adder(a[7], b[7], c6)\n  s7 = ha7.sum\n  cout = ha7.cout\n\n  ; Concatenate sum bits (high to low)\n  sum = concat(s7, s6, s5, s4, s3, s2, s1, s0)\n\n; 8-bit subtractor using two's complement\n; result = a - b = a + (~b) + 1\nmodule sub8(a:8, b:8) -> (diff:8, borrow):\n  ; Invert b\n  nb = nand(b, b)\n  ; Add with carry-in of 1 for two's complement\n  result = adder8(a, nb, 1)\n  diff = result.sum\n  ; Borrow is inverted carry out\n  borrow = nand(result.cout, result.cout)\n",
  "wire/blinker.wire": "; Simple blinker - toggles LED on each clock\n; Good for testing, demonstrates basic sequential logic\n\nmodule simple_blinker(clk) -> led:\n  led = dff(not(led), clk)\n",
  "wire/counter.wire": "; 4-bit binary counter\n; Counts from 0 to 15 and wraps around\n; Outputs the count on a 4-bit bus\n\nmodule counter4(clk, reset) -> count:4:\n  ; Increment logic: count + 1\n  inc = adder4(count, 1, 0)\n\n  ; If reset, load 0, otherwise load incremented value\n  next = mux4(reset, inc.sum, 0)\n\n  ; Store in flip-flops\n  count = dff4(next, clk)\n",
  "wire/cpu_minimal.wire": "; Minimal CPU - 34 Instruction CPU with State Machine\n; Implements: LDA #imm, LDA $addr, LDX #imm, LDX $addr, LDY #imm, LDY $addr, ADC #imm, SBC #imm, CMP #imm, AND #imm, ORA #imm, EOR #imm, STA $addr, STX $addr, STY $addr, JMP $addr, JSR $addr, RTS, BEQ rel, BNE rel, INX, DEX, INY, DEY, TAX, TAY, TXA, TYA, PHA, PLA, TXS, CLC, SEC, HLT\n;\n; State Machine (5 bits, 24 states):\n;   STATE_FETCH_OP  (0)  - Fetch opcode, increment PC\n;   STATE_DECODE    (1)  - Decode opcode, determine next state\n;   STATE_FETCH_IMM (2)  - Fetch immediate value (LDA)\n;   STATE_FETCH_LO  (3)  - Fetch address low byte (STA/JMP/JSR/LDA abs)\n;   STATE_FETCH_HI  (4)  - Fetch address high byte (STA/JMP/JSR/LDA abs)\n;   STATE_EXEC_ST   (5)  - Execute STA/STX (write to memory)\n;   STATE_EXEC_JMP  (6)  - Execute JMP (load PC)\n;   STATE_HALTED    (7)  - CPU halted\n;   STATE_PUSH      (8)  - Push A to stack (PHA) - write, don't decrement yet\n;   STATE_PULL_INC  (9)  - Increment SP for pull (PLA)\n;   STATE_PULL_READ (10) - Read from stack and load A (PLA)\n;   STATE_PUSH_DEC  (11) - Decrement SP after push (PHA)\n;   STATE_JSR_PUSH_HI (12) - JSR: Push PC high byte to stack\n;   STATE_JSR_DEC1    (13) - JSR: Decrement SP after high byte push\n;   STATE_JSR_PUSH_LO (14) - JSR: Push PC low byte to stack\n;   STATE_JSR_DONE    (15) - JSR: Decrement SP and load PC with target\n;   STATE_RTS_INC1    (16) - RTS: Increment SP before pull\n;   STATE_RTS_PULL_LO (17) - RTS: Pull low byte from stack\n;   STATE_RTS_INC2    (18) - RTS: Increment SP for high byte\n;   STATE_RTS_PULL_HI (19) - RTS: Pull high byte and load PC\n;   STATE_RESET_LO    (20) - Reset: Read low byte from $FFFC\n;   STATE_RESET_HI    (21) - Reset: Read high byte from $FFFD\n;   STATE_RESET_DONE  (22) - Reset: Load PC from reset vector\n;   STATE_EXEC_LOAD   (23) - Execute LDA/LDX/LDY abs (read from memory address)\n;\n; Inputs:\n;   clk       - Clock signal\n;   reset     - Reset CPU\n;   data_in:8 - Data from memory\n;\n; Outputs:\n;   addr:16     - Address bus (PC or operand address)\n;   data_out:8  - Data to memory (A register for STA)\n;   mem_write   - Memory write enable\n;   halted      - CPU is halted\n;   a_out:8     - Current A register value (for debugging)\n;   pc_out:16   - Current PC value (for debugging)\n;   state_out:5 - Current state (for debugging)\n\nmodule cpu_minimal(clk, reset, data_in:8) -> (addr:16, data_out:8, mem_write, halted, a_out:8, x_out:8, y_out:8, sp_out:8, flags_out:4, pc_out:16, state_out:5, debug_reset_hi:8, debug_addr_lo:8, debug_is_state_20, debug_is_state_21, debug_is_state_22, debug_addr_lo_load, debug_data_in:8, debug_pc_load, debug_reset_target:16):\n  ; ==========================================\n  ; State Register (5 bits for 32 states)\n  ; ==========================================\n  ; We use separate registers for each bit\n  state0 = dff(next_state0, clk)\n  state1 = dff(next_state1, clk)\n  state2 = dff(next_state2, clk)\n  state3 = dff(next_state3, clk)\n  state4 = dff(next_state4, clk)\n  state_out = concat(state4, state3, state2, state1, state0)\n\n  ; ==========================================\n  ; State Decoding\n  ; ==========================================\n  ns0 = not(state0)\n  ns1 = not(state1)\n  ns2 = not(state2)\n  ns3 = not(state3)\n  ns4 = not(state4)\n\n  ; is_state_0 = 00000 (FETCH_OP)\n  is_state_0 = and(and(and(and(ns4, ns3), ns2), ns1), ns0)\n\n  ; is_state_1 = 00001 (DECODE)\n  is_state_1 = and(and(and(and(ns4, ns3), ns2), ns1), state0)\n\n  ; is_state_2 = 00010 (FETCH_IMM for LDA)\n  is_state_2 = and(and(and(and(ns4, ns3), ns2), state1), ns0)\n\n  ; is_state_3 = 00011 (FETCH_LO)\n  is_state_3 = and(and(and(and(ns4, ns3), ns2), state1), state0)\n\n  ; is_state_4 = 00100 (FETCH_HI)\n  is_state_4 = and(and(and(and(ns4, ns3), state2), ns1), ns0)\n\n  ; is_state_5 = 00101 (EXEC_STA)\n  is_state_5 = and(and(and(and(ns4, ns3), state2), ns1), state0)\n\n  ; is_state_6 = 00110 (EXEC_JMP)\n  is_state_6 = and(and(and(and(ns4, ns3), state2), state1), ns0)\n\n  ; is_state_7 = 00111 (HALTED)\n  is_state_7 = and(and(and(and(ns4, ns3), state2), state1), state0)\n\n  ; is_state_8 = 01000 (PUSH - for PHA)\n  is_state_8 = and(and(and(and(ns4, state3), ns2), ns1), ns0)\n\n  ; is_state_9 = 01001 (PULL_INC - increment SP for PLA)\n  is_state_9 = and(and(and(and(ns4, state3), ns2), ns1), state0)\n\n  ; is_state_10 = 01010 (PULL_READ - read from stack for PLA)\n  is_state_10 = and(and(and(and(ns4, state3), ns2), state1), ns0)\n\n  ; is_state_11 = 01011 (PUSH_DEC - decrement SP after push)\n  is_state_11 = and(and(and(and(ns4, state3), ns2), state1), state0)\n\n  ; is_state_12 = 01100 (JSR_PUSH_HI - push PC high byte)\n  is_state_12 = and(and(and(and(ns4, state3), state2), ns1), ns0)\n\n  ; is_state_13 = 01101 (JSR_DEC1 - decrement SP after high byte push)\n  is_state_13 = and(and(and(and(ns4, state3), state2), ns1), state0)\n\n  ; is_state_14 = 01110 (JSR_PUSH_LO - push PC low byte)\n  is_state_14 = and(and(and(and(ns4, state3), state2), state1), ns0)\n\n  ; is_state_15 = 01111 (JSR_DONE - decrement SP and load PC)\n  is_state_15 = and(and(and(and(ns4, state3), state2), state1), state0)\n\n  ; is_state_16 = 10000 (RTS_INC1 - increment SP before pull)\n  is_state_16 = and(and(and(and(state4, ns3), ns2), ns1), ns0)\n\n  ; is_state_17 = 10001 (RTS_PULL_LO - pull low byte)\n  is_state_17 = and(and(and(and(state4, ns3), ns2), ns1), state0)\n\n  ; is_state_18 = 10010 (RTS_INC2 - increment SP for high byte)\n  is_state_18 = and(and(and(and(state4, ns3), ns2), state1), ns0)\n\n  ; is_state_19 = 10011 (RTS_PULL_HI - pull high byte and load PC)\n  is_state_19 = and(and(and(and(state4, ns3), ns2), state1), state0)\n\n  ; is_state_20 = 10100 (RESET_LO - read reset vector low byte from $FFFC)\n  is_state_20 = and(and(and(and(state4, ns3), state2), ns1), ns0)\n\n  ; is_state_21 = 10101 (RESET_HI - read reset vector high byte from $FFFD)\n  is_state_21 = and(and(and(and(state4, ns3), state2), ns1), state0)\n\n  ; is_state_22 = 10110 (RESET_DONE - load PC from reset vector)\n  is_state_22 = and(and(and(and(state4, ns3), state2), state1), ns0)\n\n  ; is_state_23 = 10111 (EXEC_LOAD - read from memory for LDA/LDX/LDY abs)\n  is_state_23 = and(and(and(and(state4, ns3), state2), state1), state0)\n\n  ; ==========================================\n  ; Instruction Register\n  ; ==========================================\n  ; Latch opcode during FETCH_OP state (normal case) but NOT when skipping\n  ; When skipping, load during DECODE instead (one cycle later with correct data)\n  ir_load_fetch = and(is_state_0, not(skip_pc_inc))\n  ir_load_decode_after_skip = and(is_state_1, skip_pc_inc)\n  ir_load = or(ir_load_fetch, ir_load_decode_after_skip)\n  ir = register8(data_in, ir_load, clk)\n\n  ; When loading IR during DECODE, bypass register and decode data_in directly\n  ; This avoids a 1-cycle delay when skip_pc_inc forces IR load during DECODE\n  ir_for_decode = mux8(ir, data_in, ir_load_decode_after_skip)\n\n  ; Decode the instruction\n  dec = decoder(ir_for_decode)\n  \n  ; ==========================================\n  ; Address Latch (low and high bytes)\n  ; ==========================================\n  ; Latch low byte during FETCH_LO (3) or RESET_LO (20)\n  addr_lo_load = or(is_state_3, is_state_20)\n  addr_lo = register8(data_in, addr_lo_load, clk)\n\n  ; Latch high byte during FETCH_HI (4)\n  addr_hi = register8(data_in, is_state_4, clk)\n\n  ; Reset vector high byte register - latch during RESET_HI (21)\n  reset_hi = register8(data_in, is_state_21, clk)\n\n  ; ==========================================\n  ; Branch Offset (for BEQ/BNE)\n  ; ==========================================\n  ; Latch offset byte during FETCH_IMM when instruction is BEQ or BNE\n  is_branch = or(dec.is_beq, dec.is_bne)\n  offset_load = and(is_state_2, is_branch)\n  offset = register8(data_in, offset_load, clk)\n\n  ; ==========================================\n  ; RTS Return Address Low Byte\n  ; ==========================================\n  ; Latch low byte of return address during RTS_PULL_LO (state 17)\n  ret_lo_load = is_state_17\n  ret_lo = register8(data_in, ret_lo_load, clk)\n\n  ; ==========================================\n  ; Accumulator (A register)\n  ; ==========================================\n  ; Load A during FETCH_IMM when instruction is LDA, ADC, SBC, AND, ORA, EOR (NOT CMP)\n  ; CMP sets flags like SBC but doesn't store result\n  ; Load A during DECODE when instruction is TXA or TYA (implied addressing)\n  ; Load A during PULL_READ (state 10) when instruction is PLA\n  ; Load A during EXEC_LOAD (state 23) when instruction is LDA abs\n  is_arith_op = or(dec.is_adc, dec.is_sbc)\n  is_logic_op = or(or(dec.is_and, dec.is_ora), dec.is_eor)\n  is_alu_op = or(is_arith_op, is_logic_op)\n  is_alu_or_cmp = or(is_alu_op, dec.is_cmp)\n  is_txa_tya = or(dec.is_txa, dec.is_tya)\n  a_load_imm = and(is_state_2, or(dec.is_lda, is_alu_op))\n  a_load_transfer = and(is_state_1, is_txa_tya)\n  a_load_pla = is_state_10  ; PLA loads A from stack in state 10\n  a_load_abs = and(is_state_23, dec.is_lda_abs)  ; LDA abs loads A in state 23\n  a_load = or(or(or(a_load_imm, a_load_transfer), a_load_pla), a_load_abs)\n  ; Mux between data_in (for LDA), alu.result (for ADC/SBC/AND/ORA/EOR), X (for TXA), Y (for TYA)\n  a_src_imm = mux8(data_in, alu.result, is_alu_op)\n  a_src_xy = mux8(x_out, y_out, dec.is_tya)\n  a_src_imm_or_xy = mux8(a_src_imm, a_src_xy, is_txa_tya)\n  ; For PLA (state 10) and LDA abs (state 23), always use data_in directly\n  a_load_from_mem = or(a_load_pla, a_load_abs)\n  a_data_src = mux8(a_src_imm_or_xy, data_in, a_load_from_mem)\n  a_out = register8(a_data_src, a_load, clk)\n\n  ; ==========================================\n  ; X Index Register\n  ; ==========================================\n  ; Load X during FETCH_IMM when instruction is LDX\n  ; Load X during DECODE when instruction is INX, DEX, or TAX (implied addressing)\n  ; Load X during EXEC_LOAD (state 23) when instruction is LDX abs\n  is_inx_dex = or(dec.is_inx, dec.is_dex)\n  x_load_ldx = and(is_state_2, dec.is_ldx)\n  x_load_inx_dex = and(is_state_1, is_inx_dex)\n  x_load_tax = and(is_state_1, dec.is_tax)\n  x_load_ldx_abs = and(is_state_23, dec.is_ldx_abs)  ; LDX abs loads X in state 23\n  x_load = or(or(or(x_load_ldx, x_load_inx_dex), x_load_tax), x_load_ldx_abs)\n\n  ; Compute X+1 and X-1 for INX/DEX\n  ; INX: X + 1 (use adder8 with b=1, cin=0)\n  ; DEX: X - 1 (use adder8 with b=0xFF, cin=0 which is X + 255 = X - 1 in 2's complement)\n  ; Actually simpler: use adder8 with b=1/0xFF depending on instruction\n  inx_addend = concat(0, 0, 0, 0, 0, 0, 0, 1)  ; 0x01\n  dex_addend = concat(1, 1, 1, 1, 1, 1, 1, 1)  ; 0xFF (-1 in 2's complement)\n  x_addend = mux8(inx_addend, dex_addend, dec.is_dex)\n  x_inc_result = adder8(x_out, x_addend, 0)\n\n  ; Select source for X: data_in for LDX/LDX abs, x_inc_result for INX/DEX, a_out for TAX\n  x_load_from_mem = or(x_load_ldx, x_load_ldx_abs)\n  x_src_ldx_or_inc = mux8(data_in, x_inc_result.sum, is_inx_dex)\n  x_src_with_abs = mux8(x_src_ldx_or_inc, data_in, x_load_ldx_abs)\n  x_data_src = mux8(x_src_with_abs, a_out, dec.is_tax)\n  x_out = register8(x_data_src, x_load, clk)\n\n  ; ==========================================\n  ; Y Index Register\n  ; ==========================================\n  ; Load Y during FETCH_IMM when instruction is LDY\n  ; Load Y during DECODE when instruction is INY, DEY, or TAY (implied addressing)\n  ; Load Y during EXEC_LOAD (state 23) when instruction is LDY abs\n  is_iny_dey = or(dec.is_iny, dec.is_dey)\n  y_load_ldy = and(is_state_2, dec.is_ldy)\n  y_load_iny_dey = and(is_state_1, is_iny_dey)\n  y_load_tay = and(is_state_1, dec.is_tay)\n  y_load_ldy_abs = and(is_state_23, dec.is_ldy_abs)  ; LDY abs loads Y in state 23\n  y_load = or(or(or(y_load_ldy, y_load_iny_dey), y_load_tay), y_load_ldy_abs)\n\n  ; Compute Y+1 and Y-1 for INY/DEY\n  iny_addend = concat(0, 0, 0, 0, 0, 0, 0, 1)  ; 0x01\n  dey_addend = concat(1, 1, 1, 1, 1, 1, 1, 1)  ; 0xFF (-1 in 2's complement)\n  y_addend = mux8(iny_addend, dey_addend, dec.is_dey)\n  y_inc_result = adder8(y_out, y_addend, 0)\n\n  ; Select source for Y: data_in for LDY/LDY abs, y_inc_result for INY/DEY, a_out for TAY\n  y_load_from_mem = or(y_load_ldy, y_load_ldy_abs)\n  y_src_ldy_or_inc = mux8(data_in, y_inc_result.sum, is_iny_dey)\n  y_src_with_abs = mux8(y_src_ldy_or_inc, data_in, y_load_ldy_abs)\n  y_data_src = mux8(y_src_with_abs, a_out, dec.is_tay)\n  y_out = register8(y_data_src, y_load, clk)\n\n  ; ==========================================\n  ; Stack Pointer (SP) Register\n  ; ==========================================\n  ; SP starts at 0xFF on reset (points to next free location)\n  ; Stack is at $0100-$01FF (page 1)\n  ; PHA: write A to $0100+SP, then SP-- (decrement after push)\n  ; PLA: SP++, then read from $0100+SP (increment before pull)\n  ; JSR: push PC high, SP--, push PC low, SP-- (two decrements)\n  ; RTS: SP++, pull low, SP++, pull high (two increments)\n  ;\n  ; SP is updated:\n  ;   - On PHA in STATE_PUSH_DEC (11): SP = SP - 1 (after writing)\n  ;   - On PLA in STATE_PULL_INC (9): SP = SP + 1 (before reading)\n  ;   - On JSR in STATE_JSR_DEC1 (13): SP = SP - 1 (after pushing high byte)\n  ;   - On JSR in STATE_JSR_DONE (15): SP = SP - 1 (after pushing low byte)\n  ;   - On RTS in STATE_RTS_INC1 (16): SP = SP + 1 (before pulling low byte)\n  ;   - On RTS in STATE_RTS_INC2 (18): SP = SP + 1 (before pulling high byte)\n  sp_inc_addend = concat(0, 0, 0, 0, 0, 0, 0, 1)  ; 0x01\n  sp_dec_addend = concat(1, 1, 1, 1, 1, 1, 1, 1)  ; 0xFF (-1)\n\n  ; Compute SP+1 and SP-1\n  sp_inc_result = adder8(sp_out, sp_inc_addend, 0)\n  sp_dec_result = adder8(sp_out, sp_dec_addend, 0)\n\n  ; Load SP: decrement for push operations, increment for pull operations\n  ; Also load SP from X register for TXS instruction\n  sp_load_pha_dec = is_state_11    ; PHA: decrement after push write\n  sp_load_pla_inc = is_state_9     ; PLA: increment before pull read\n  sp_load_jsr_dec1 = is_state_13   ; JSR: decrement after pushing high byte\n  sp_load_jsr_dec2 = is_state_15   ; JSR: decrement after pushing low byte\n  sp_load_rts_inc1 = is_state_16   ; RTS: increment before pulling low byte\n  sp_load_rts_inc2 = is_state_18   ; RTS: increment before pulling high byte\n  sp_load_txs = and(is_state_1, dec.is_txs)  ; TXS: load SP from X in DECODE\n\n  ; Combine all decrement operations\n  sp_load_dec = or(or(sp_load_pha_dec, sp_load_jsr_dec1), sp_load_jsr_dec2)\n  ; Combine all increment operations\n  sp_load_inc = or(or(sp_load_pla_inc, sp_load_rts_inc1), sp_load_rts_inc2)\n  sp_load = or(or(sp_load_dec, sp_load_inc), sp_load_txs)\n\n  ; Select between increment and decrement (for stack ops)\n  sp_next_stack = mux8(sp_dec_result.sum, sp_inc_result.sum, sp_load_inc)\n  ; Select between stack ops result and X register (for TXS)\n  sp_next = mux8(sp_next_stack, x_out, sp_load_txs)\n\n  ; On reset, SP should be 0xFF\n  ; We achieve this by loading 0xFF on reset\n  sp_reset_val = concat(1, 1, 1, 1, 1, 1, 1, 1)  ; 0xFF\n  sp_load_or_reset = or(sp_load, reset)\n  sp_data = mux8(sp_next, sp_reset_val, reset)\n  sp_out = register8(sp_data, sp_load_or_reset, clk)\n\n  ; Stack address for memory access: $0100 + SP\n  ; For PHA: use current SP (before decrement)\n  ; For PLA: use incremented SP (after increment in state 9)\n  stack_addr_lo = sp_out\n  stack_addr_hi = concat(0, 0, 0, 0, 0, 0, 0, 1)  ; 0x01\n  stack_addr = concat(stack_addr_hi, stack_addr_lo)\n\n  ; ==========================================\n  ; ALU and Flags\n  ; ==========================================\n  ; ALU always computes (used when needed)\n  ; For ADC: op=000 (ADD), a=A register, b=data_in, cin=carry flag\n  ; For SBC: op=001 (SUB), a=A register, b=data_in, cin=carry flag (borrow)\n  ; For CMP: op=001 (SUB), a=A register, b=data_in, cin=1 (no borrow)\n  ; For AND: op=010 (AND), a=A register, b=data_in\n  ; For ORA: op=011 (OR), a=A register, b=data_in\n  ; For EOR: op=100 (XOR), a=A register, b=data_in\n  ;\n  ; alu_op encoding: [2:0]\n  ;   000 = ADD (ADC)\n  ;   001 = SUB (SBC, CMP)\n  ;   010 = AND\n  ;   011 = OR (ORA)\n  ;   100 = XOR (EOR)\n  is_sub_op = or(dec.is_sbc, dec.is_cmp)\n  ; op[0] = 1 for SBC/CMP/ORA, 0 for ADC/AND/EOR\n  alu_op_0 = or(is_sub_op, dec.is_ora)\n  ; op[1] = 1 for AND/ORA, 0 for ADC/SBC/CMP/EOR\n  alu_op_1 = or(dec.is_and, dec.is_ora)\n  ; op[2] = 1 for EOR, 0 for others\n  alu_op_2 = dec.is_eor\n  alu_op = concat(alu_op_2, alu_op_1, alu_op_0)\n\n  ; cin_for_alu: Carry input to ALU, only updates in FETCH_OP (state 0)\n  ; This ensures cin stays constant throughout multi-cycle ADC execution\n  ; For CMP, always use cin=1 (no borrow, pure comparison)\n  cin_update = is_state_0\n  cin_next = and(cin_update, flag_c_out)\n  cin_hold = and(not(cin_update), cin_for_alu_saved)\n  cin_for_alu_in = or(cin_next, cin_hold)\n  cin_for_alu_before_reset = dff(cin_for_alu_in, clk)\n  ; Force cin=0 during reset\n  cin_for_alu_saved = and(cin_for_alu_before_reset, not(reset))\n  ; For CMP, override with 1; for ADC/SBC, use saved carry\n  cin_for_alu = mux(cin_for_alu_saved, 1, dec.is_cmp)\n\n  alu = alu8(a_out, data_in, alu_op, cin_for_alu)\n\n  ; Flag register: Use 4 separate DFFs instead of register8 to avoid bit indexing issues\n  ; flags_out[0] = C (carry), flags_out[1] = Z (zero), flags_out[2] = N (negative), flags_out[3] = V (overflow)\n  ; Flags are updated during:\n  ;   - FETCH_IMM (state 2) for ADC/SBC/CMP (when data_in contains the operand)\n  ;   - DECODE (state 1) for INX/DEX/INY/DEY (implied mode, single-cycle)\n  ;   - DECODE (state 1) for TAX/TAY/TXA/TYA (implied mode, single-cycle)\n  ;   - FETCH_IMM (state 2) for LDA/LDX/LDY (after loading data_in)\n  ;   - PULL_READ (state 10) for PLA (after loading data_in from stack)\n  ;   - EXEC_LOAD (state 23) for LDA/LDX/LDY abs (after loading data_in from memory)\n  is_inc_dec_xy = or(is_inx_dex, is_iny_dey)\n  is_transfer = or(or(dec.is_tax, dec.is_tay), is_txa_tya)\n  flags_load_alu = and(is_state_2, is_alu_or_cmp)\n  flags_load_inc_dec = and(is_state_1, is_inc_dec_xy)\n  flags_load_transfer = and(is_state_1, is_transfer)\n  is_load_axy = or(or(dec.is_lda, dec.is_ldx), dec.is_ldy)\n  flags_load_load = and(is_state_2, is_load_axy)\n  flags_load_pla = is_state_10  ; PLA sets Z/N based on pulled value\n  flags_load_load_abs = is_state_23  ; LDA/LDX/LDY abs sets Z/N in state 23\n  flags_load = or(or(or(or(or(flags_load_alu, flags_load_inc_dec), flags_load_transfer), flags_load_load), flags_load_pla), flags_load_load_abs)\n\n  ; Compute Z and N flags from data_in for LDA/LDX/LDY\n  ; Z = 1 if data_in is all zeros (use NOR reduction)\n  data_in_or01 = or(data_in[0], data_in[1])\n  data_in_or23 = or(data_in[2], data_in[3])\n  data_in_or45 = or(data_in[4], data_in[5])\n  data_in_or67 = or(data_in[6], data_in[7])\n  data_in_or0123 = or(data_in_or01, data_in_or23)\n  data_in_or4567 = or(data_in_or45, data_in_or67)\n  data_in_any = or(data_in_or0123, data_in_or4567)\n  data_in_z = not(data_in_any)\n  ; N = bit 7 of data_in\n  data_in_n = data_in[7]\n\n  ; Compute Z and N flags from x_inc_result for INX/DEX\n  x_res_or01 = or(x_inc_result.sum[0], x_inc_result.sum[1])\n  x_res_or23 = or(x_inc_result.sum[2], x_inc_result.sum[3])\n  x_res_or45 = or(x_inc_result.sum[4], x_inc_result.sum[5])\n  x_res_or67 = or(x_inc_result.sum[6], x_inc_result.sum[7])\n  x_res_or0123 = or(x_res_or01, x_res_or23)\n  x_res_or4567 = or(x_res_or45, x_res_or67)\n  x_res_any = or(x_res_or0123, x_res_or4567)\n  x_res_z = not(x_res_any)\n  x_res_n = x_inc_result.sum[7]\n\n  ; Compute Z and N flags from y_inc_result for INY/DEY\n  y_res_or01 = or(y_inc_result.sum[0], y_inc_result.sum[1])\n  y_res_or23 = or(y_inc_result.sum[2], y_inc_result.sum[3])\n  y_res_or45 = or(y_inc_result.sum[4], y_inc_result.sum[5])\n  y_res_or67 = or(y_inc_result.sum[6], y_inc_result.sum[7])\n  y_res_or0123 = or(y_res_or01, y_res_or23)\n  y_res_or4567 = or(y_res_or45, y_res_or67)\n  y_res_any = or(y_res_or0123, y_res_or4567)\n  y_res_z = not(y_res_any)\n  y_res_n = y_inc_result.sum[7]\n\n  ; Compute Z and N flags from a_out for TAX/TAY\n  a_or01 = or(a_out[0], a_out[1])\n  a_or23 = or(a_out[2], a_out[3])\n  a_or45 = or(a_out[4], a_out[5])\n  a_or67 = or(a_out[6], a_out[7])\n  a_or0123 = or(a_or01, a_or23)\n  a_or4567 = or(a_or45, a_or67)\n  a_any = or(a_or0123, a_or4567)\n  a_z = not(a_any)\n  a_n = a_out[7]\n\n  ; Compute Z and N flags from x_out for TXA\n  x_or01 = or(x_out[0], x_out[1])\n  x_or23 = or(x_out[2], x_out[3])\n  x_or45 = or(x_out[4], x_out[5])\n  x_or67 = or(x_out[6], x_out[7])\n  x_or0123 = or(x_or01, x_or23)\n  x_or4567 = or(x_or45, x_or67)\n  x_any = or(x_or0123, x_or4567)\n  x_z = not(x_any)\n  x_n = x_out[7]\n\n  ; Compute Z and N flags from y_out for TYA\n  y_or01 = or(y_out[0], y_out[1])\n  y_or23 = or(y_out[2], y_out[3])\n  y_or45 = or(y_out[4], y_out[5])\n  y_or67 = or(y_out[6], y_out[7])\n  y_or0123 = or(y_or01, y_or23)\n  y_or4567 = or(y_or45, y_or67)\n  y_any = or(y_or0123, y_or4567)\n  y_z = not(y_any)\n  y_n = y_out[7]\n\n  ; Select flag sources:\n  ; - ALU for ADC/SBC/CMP/AND/ORA/EOR\n  ; - x_inc_result for INX/DEX\n  ; - y_inc_result for INY/DEY\n  ; - a_out for TAX/TAY, x_out for TXA, y_out for TYA\n  ; - data_in for LDA/LDX/LDY\n  ;\n  ; Transfer flag sources:\n  ;   TAX/TAY: use A value (source of transfer)\n  ;   TXA: use X value (source of transfer)\n  ;   TYA: use Y value (source of transfer)\n  is_tax_tay = or(dec.is_tax, dec.is_tay)\n  flag_z_from_xy_transfer = mux(x_z, y_z, dec.is_tya)\n  flag_n_from_xy_transfer = mux(x_n, y_n, dec.is_tya)\n  flag_z_from_transfer = mux(flag_z_from_xy_transfer, a_z, is_tax_tay)\n  flag_n_from_transfer = mux(flag_n_from_xy_transfer, a_n, is_tax_tay)\n\n  ; First: mux between X and Y inc results based on which instruction\n  flag_z_from_xy = mux(x_res_z, y_res_z, is_iny_dey)\n  flag_n_from_xy = mux(x_res_n, y_res_n, is_iny_dey)\n  ; Then: mux between ALU and XY inc results\n  flag_z_from_alu_or_xy = mux(alu.z, flag_z_from_xy, is_inc_dec_xy)\n  flag_n_from_alu_or_xy = mux(alu.n, flag_n_from_xy, is_inc_dec_xy)\n  ; Then: mux with transfer instructions\n  flag_z_from_alu_xy_transfer = mux(flag_z_from_alu_or_xy, flag_z_from_transfer, is_transfer)\n  flag_n_from_alu_xy_transfer = mux(flag_n_from_alu_or_xy, flag_n_from_transfer, is_transfer)\n  ; Finally: mux with data_in for load instructions (LDA/LDX/LDY, PLA, and load abs)\n  flags_load_from_data_in = or(or(flags_load_load, flags_load_pla), flags_load_load_abs)\n  flag_z_src = mux(flag_z_from_alu_xy_transfer, data_in_z, flags_load_from_data_in)\n  flag_n_src = mux(flag_n_from_alu_xy_transfer, data_in_n, flags_load_from_data_in)\n\n  ; Individual flag registers - load when flags_load is high, clear on reset\n  ; C flag: Updated by ADC, SBC, CMP, CLC, and SEC\n  ; is_arith_or_cmp = is_arith_op OR is_cmp (ADC, SBC, CMP only)\n  is_arith_or_cmp = or(is_arith_op, dec.is_cmp)\n  flags_load_c_arith = and(is_state_2, is_arith_or_cmp)  ; Arithmetic ops update carry from ALU in FETCH_IMM\n  flags_load_c_clc = and(is_state_1, dec.is_clc)  ; CLC clears carry\n  flags_load_c_sec = and(is_state_1, dec.is_sec)  ; SEC sets carry\n  flags_load_c = or(or(flags_load_c_arith, flags_load_c_clc), flags_load_c_sec)\n  ; Carry value: from ALU for arith ops, 0 for CLC, 1 for SEC\n  flag_c_from_arith = and(flags_load_c_arith, alu.cout)\n  flag_c_from_sec = flags_load_c_sec  ; SEC sets carry to 1\n  ; CLC sets carry to 0 (already implicit - if only CLC, result is 0)\n  flag_c_next = or(flag_c_from_arith, flag_c_from_sec)\n  flag_c_hold = and(not(flags_load_c), flag_c_out)\n  flag_c_before_reset = or(flag_c_next, flag_c_hold)\n  flag_c_in = and(flag_c_before_reset, not(reset))\n  flag_c_out = dff(flag_c_in, clk)\n\n  ; Z flag: Updated by ADC, SBC, CMP, AND, ORA, EOR, LDA, LDX, INX, DEX\n  ; flags_load already includes logic ops via is_alu_or_cmp\n  flag_z_next = and(flags_load, flag_z_src)\n  flag_z_hold = and(not(flags_load), flag_z_out)\n  flag_z_before_reset = or(flag_z_next, flag_z_hold)\n  flag_z_in = and(flag_z_before_reset, not(reset))\n  flag_z_out = dff(flag_z_in, clk)\n\n  ; N flag: Updated by ADC, SBC, CMP, AND, ORA, EOR, LDA, LDX, INX, DEX\n  flag_n_next = and(flags_load, flag_n_src)\n  flag_n_hold = and(not(flags_load), flag_n_out)\n  flag_n_before_reset = or(flag_n_next, flag_n_hold)\n  flag_n_in = and(flag_n_before_reset, not(reset))\n  flag_n_out = dff(flag_n_in, clk)\n\n  ; V flag: Updated by ADC and SBC only (NOT logic ops, NOT CMP)\n  flags_load_v = and(is_state_2, is_arith_op)  ; Only ADC/SBC update overflow in FETCH_IMM\n  flag_v_next = and(flags_load_v, alu.vout)\n  flag_v_hold = and(not(flags_load_v), flag_v_out)\n  flag_v_before_reset = or(flag_v_next, flag_v_hold)\n  flag_v_in = and(flag_v_before_reset, not(reset))\n  flag_v_out = dff(flag_v_in, clk)\n\n  ; Combine stored flags: [V, N, Z, C] = [bit3, bit2, bit1, bit0]\n  flags_out = concat(flag_v_out, flag_n_out, flag_z_out, flag_c_out)\n\n  ; ==========================================\n  ; Program Counter\n  ; ==========================================\n  ; Build 16-bit address from latches (for JMP and JSR)\n  jmp_target = concat(addr_hi, addr_lo)\n\n  ; Build return address for RTS: high byte from data_in (current read), low byte from ret_lo (saved)\n  rts_target = concat(data_in, ret_lo)\n\n  ; Build branch target for BEQ: (PC+1) + sign_extended_offset\n  ; The +1 accounts for the pending PC increment in state 2\n  ; So the offset is relative to PC+2 (address after the 2-byte BEQ instruction)\n  ; NOTE: Use data_in directly (not offset register output) for branch calculation\n  ; This ensures the branch target is computed combinationally in the same cycle\n  ; as the branch decision, without depending on register feedback timing\n  sign_bit = data_in[7]\n  offset_hi = concat(sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit)\n  offset_16 = concat(offset_hi, data_in)\n\n  ; Add offset to (PC + 1) by using carry-in=1\n  branch_result = adder16(pc_out, offset_16, 1)\n  branch_target = branch_result.sum\n\n  ; Select PC target based on instruction type:\n  ; - JMP/JSR: use jmp_target (addr_hi:addr_lo)\n  ; - BEQ/BNE: use branch_target\n  ; - RTS: use rts_target (data_in:ret_lo)\n  ; - Reset: use reset_target - high byte from reset_hi (state 21), low byte from addr_lo (state 20)\n  reset_target = concat(reset_hi, addr_lo)\n  pc_target_jmp_or_branch = mux16(jmp_target, branch_target, is_branch)\n  pc_target_with_rts = mux16(pc_target_jmp_or_branch, rts_target, is_state_19)\n  pc_target = mux16(pc_target_with_rts, reset_target, is_state_22)\n\n  ; Skip PC increment flag: set when in EXEC states, cleared after DECODE\n  ; The flag needs to persist through FETCH_OP and DECODE states\n  ; Set when in EXEC (will be active next cycle when we enter FETCH_OP)\n  ; Include PUSH_DEC (11), PULL_READ (10), JSR_DONE (15), RTS_PULL_HI (19), RESET_DONE (22), EXEC_LOAD (23)\n  set_skip_basic = or(or(is_state_5, is_state_6), or(is_state_11, is_state_10))\n  set_skip_jsr_rts = or(is_state_15, is_state_19)\n  set_skip_reset = is_state_22\n  set_skip_load = is_state_23  ; EXEC_LOAD also needs to skip PC inc\n  set_skip = or(or(or(set_skip_basic, set_skip_jsr_rts), set_skip_reset), set_skip_load)\n  ; Clear after DECODE (when in FETCH_IMM, FETCH_LO, HALTED, PULL_INC, RTS_INC1), OR on reset\n  clear_skip_states = or(or(or(or(is_state_2, is_state_3), is_state_7), is_state_9), is_state_16)\n  clear_skip = or(clear_skip_states, reset)\n  ; Keep current value if neither setting nor clearing\n  keep_skip = and(not(set_skip), not(clear_skip))\n  next_skip_val = or(set_skip, and(skip_pc_inc, keep_skip))\n  skip_pc_inc = dff(next_skip_val, clk)\n\n  ; PC increment during fetch states, but NOT in FETCH_OP if skip flag is set\n  ; When skipping FETCH_OP increment, increment during DECODE instead (when loading IR)\n  inc_in_fetch_op = and(is_state_0, not(skip_pc_inc))\n  inc_in_decode_after_skip = and(is_state_1, skip_pc_inc)\n  pc_inc = or(or(or(inc_in_fetch_op, inc_in_decode_after_skip), is_state_2), or(is_state_3, is_state_4))\n\n  ; PC load during:\n  ;   - JMP execute (state 6)\n  ;   - BEQ taken (state 2, Z=1)\n  ;   - BNE taken (state 2, Z=0)\n  ;   - JSR done (state 15)\n  ;   - RTS done (state 19)\n  ;   - Reset done (state 21)\n  pc_load_jmp = is_state_6\n  ; BEQ loads PC when in state 2, instruction is BEQ, and Z flag is set\n  pc_load_beq = and(and(is_state_2, dec.is_beq), flag_z_out)\n  ; BNE loads PC when in state 2, instruction is BNE, and Z flag is clear\n  pc_load_bne = and(and(is_state_2, dec.is_bne), not(flag_z_out))\n  ; JSR loads PC in state 15 (JSR_DONE)\n  pc_load_jsr = is_state_15\n  ; RTS loads PC in state 19 (RTS_PULL_HI)\n  pc_load_rts = is_state_19\n  ; Reset loads PC in state 22 (RESET_DONE) from reset vector\n  pc_load_reset = is_state_22\n  pc_load_basic = or(or(or(pc_load_jmp, pc_load_beq), pc_load_bne), pc_load_jsr)\n  pc_load = or(or(pc_load_basic, pc_load_rts), pc_load_reset)\n\n  pc_out = pc(clk, reset, pc_load, pc_inc, pc_target)\n  \n  ; ==========================================\n  ; Next State Logic (5-bit state machine)\n  ; ==========================================\n  ; States: 0=FETCH_OP, 1=DECODE, 2=FETCH_IMM, 3=FETCH_LO, 4=FETCH_HI,\n  ;         5=EXEC_ST, 6=EXEC_JMP, 7=HALTED, 8=PUSH, 9=PULL_INC, 10=PULL_READ, 11=PUSH_DEC\n  ;         12=JSR_PUSH_HI, 13=JSR_DEC1, 14=JSR_PUSH_LO, 15=JSR_DONE\n  ;         16=RTS_INC1, 17=RTS_PULL_LO, 18=RTS_INC2, 19=RTS_PULL_HI\n\n  ; From FETCH_OP (0) -> DECODE (1): next = 00001\n  from_0_to_1 = is_state_0\n\n  ; From DECODE (1):\n  ;   if LDA/LDX/LDY/ADC/CMP/BEQ/BNE/AND/ORA/EOR/SBC -> FETCH_IMM (2): next = 00010\n  ;   if STA/STX/STY/JMP/JSR/LDA_abs/LDX_abs/LDY_abs -> FETCH_LO (3): next = 00011\n  ;   if INX/DEX/INY/DEY/TAX/TAY/TXA/TYA/TXS/CLC/SEC -> FETCH_OP (0): next = 00000 (implied, single-cycle)\n  ;   if PHA -> PUSH (8): next = 01000\n  ;   if PLA -> PULL_INC (9): next = 01001\n  ;   if RTS -> RTS_INC1 (16): next = 10000\n  ;   if HLT -> HALTED (7): next = 00111\n  needs_byte = or(dec.needs_imm, dec.needs_rel)\n  from_1_to_2 = and(is_state_1, needs_byte)\n  ; needs_addr covers stores and jumps; needs_load_addr covers load abs instructions\n  needs_any_addr = or(dec.needs_addr, dec.needs_load_addr)\n  from_1_to_3 = and(is_state_1, needs_any_addr)\n  ; Include TXS, CLC, SEC in implied single-cycle instructions\n  is_flag_op = or(dec.is_clc, dec.is_sec)\n  is_implied_single_cycle = or(or(or(is_inc_dec_xy, is_transfer), dec.is_txs), is_flag_op)\n  from_1_to_0 = and(is_state_1, is_implied_single_cycle)\n  from_1_to_7 = and(is_state_1, dec.is_hlt)\n  from_1_to_8 = and(is_state_1, dec.is_pha)\n  from_1_to_9 = and(is_state_1, dec.is_pla)\n  from_1_to_16 = and(is_state_1, dec.is_rts)\n\n  ; From FETCH_IMM (2) -> FETCH_OP (0): next = 00000\n  from_2_to_0 = is_state_2\n\n  ; From FETCH_LO (3) -> FETCH_HI (4): next = 00100\n  from_3_to_4 = is_state_3\n\n  ; From FETCH_HI (4):\n  ;   if STA/STX/STY -> EXEC_ST (5): next = 00101\n  ;   if JMP -> EXEC_JMP (6): next = 00110\n  ;   if JSR -> JSR_PUSH_HI (12): next = 01100\n  ;   if LDA_abs/LDX_abs/LDY_abs -> EXEC_LOAD (23): next = 10111\n  is_store = or(or(dec.is_sta, dec.is_stx), dec.is_sty)\n  from_4_to_5 = and(is_state_4, is_store)\n  from_4_to_6 = and(is_state_4, dec.is_jmp)\n  from_4_to_12 = and(is_state_4, dec.is_jsr)\n  from_4_to_23 = and(is_state_4, dec.needs_load_addr)  ; Load abs -> EXEC_LOAD\n\n  ; From EXEC_ST (5) -> FETCH_OP (0): next = 00000\n  from_5_to_0 = is_state_5\n\n  ; From EXEC_JMP (6) -> FETCH_OP (0): next = 00000\n  from_6_to_0 = is_state_6\n\n  ; HALTED (7) stays at 7: next = 00111\n  stay_at_7 = is_state_7\n\n  ; From PUSH (8) -> PUSH_DEC (11): next = 01011 (write done, now decrement SP)\n  from_8_to_11 = is_state_8\n\n  ; From PULL_INC (9) -> PULL_READ (10): next = 01010 (SP incremented, now read)\n  from_9_to_10 = is_state_9\n\n  ; From PULL_READ (10) -> FETCH_OP (0): next = 00000 (PLA done)\n  from_10_to_0 = is_state_10\n\n  ; From PUSH_DEC (11) -> FETCH_OP (0): next = 00000 (SP decremented, PHA done)\n  from_11_to_0 = is_state_11\n\n  ; JSR state transitions:\n  ; From JSR_PUSH_HI (12) -> JSR_DEC1 (13): next = 01101 (high byte pushed, decrement SP)\n  from_12_to_13 = is_state_12\n\n  ; From JSR_DEC1 (13) -> JSR_PUSH_LO (14): next = 01110 (SP decremented, push low byte)\n  from_13_to_14 = is_state_13\n\n  ; From JSR_PUSH_LO (14) -> JSR_DONE (15): next = 01111 (low byte pushed, finalize)\n  from_14_to_15 = is_state_14\n\n  ; From JSR_DONE (15) -> FETCH_OP (0): next = 00000 (SP decremented, PC loaded, done)\n  from_15_to_0 = is_state_15\n\n  ; RTS state transitions:\n  ; From RTS_INC1 (16) -> RTS_PULL_LO (17): next = 10001 (SP incremented, read low byte)\n  from_16_to_17 = is_state_16\n\n  ; From RTS_PULL_LO (17) -> RTS_INC2 (18): next = 10010 (low byte read, increment SP)\n  from_17_to_18 = is_state_17\n\n  ; From RTS_INC2 (18) -> RTS_PULL_HI (19): next = 10011 (SP incremented, read high byte)\n  from_18_to_19 = is_state_18\n\n  ; From RTS_PULL_HI (19) -> FETCH_OP (0): next = 00000 (PC loaded, done)\n  from_19_to_0 = is_state_19\n\n  ; Reset state transitions:\n  ; From RESET_LO (20) -> RESET_HI (21): next = 10101 (low byte read, read high byte)\n  from_20_to_21 = is_state_20\n\n  ; From RESET_HI (21) -> RESET_DONE (22): next = 10110 (high byte read, load PC)\n  from_21_to_22 = is_state_21\n\n  ; From RESET_DONE (22) -> FETCH_OP (0): next = 00000 (PC loaded from reset vector, done)\n  from_22_to_0 = is_state_22\n\n  ; From EXEC_LOAD (23) -> FETCH_OP (0): next = 00000 (load abs complete)\n  from_23_to_0 = is_state_23\n\n  ; Calculate next state bits (5-bit encoding)\n  ; Binary encodings:\n  ;   0=00000, 1=00001, 2=00010, 3=00011, 4=00100, 5=00101, 6=00110, 7=00111\n  ;   8=01000, 9=01001, 10=01010, 11=01011, 12=01100, 13=01101, 14=01110, 15=01111\n  ;   16=10000, 17=10001, 18=10010, 19=10011, 20=10100, 21=10101, 22=10110, 23=10111\n\n  ; Bit 0: set for states 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23\n  goto_1 = from_0_to_1\n  goto_3 = from_1_to_3\n  goto_5 = from_4_to_5\n  goto_7 = or(from_1_to_7, stay_at_7)\n  goto_9 = from_1_to_9\n  goto_11 = from_8_to_11\n  goto_13 = from_12_to_13\n  goto_15 = from_14_to_15\n  goto_17 = from_16_to_17\n  goto_19 = from_18_to_19\n  goto_21 = from_20_to_21\n  goto_23 = from_4_to_23  ; Load abs -> EXEC_LOAD\n  set_bit_0_low = or(or(or(goto_1, goto_3), or(goto_5, goto_7)), or(goto_9, goto_11))\n  set_bit_0_high = or(or(or(goto_13, goto_15), or(goto_17, goto_19)), or(goto_21, goto_23))\n  set_bit_0 = or(set_bit_0_low, set_bit_0_high)\n\n  ; Bit 1: set for states 2, 3, 6, 7, 10, 11, 14, 15, 18, 19, 22, 23\n  goto_2 = from_1_to_2\n  goto_6 = from_4_to_6\n  goto_10 = from_9_to_10\n  goto_14 = from_13_to_14\n  goto_18 = from_17_to_18\n  goto_22 = from_21_to_22\n  set_bit_1_low = or(or(or(goto_2, goto_3), or(goto_6, goto_7)), or(goto_10, goto_11))\n  set_bit_1_high = or(or(or(goto_14, goto_15), or(goto_18, goto_19)), or(goto_22, goto_23))\n  set_bit_1 = or(set_bit_1_low, set_bit_1_high)\n\n  ; Bit 2: set for states 4, 5, 6, 7, 12, 13, 14, 15, 20, 21, 22, 23\n  goto_4 = from_3_to_4\n  goto_12 = from_4_to_12\n  goto_20 = reset  ; On reset, go to state 20\n  set_bit_2_low = or(or(goto_4, goto_5), or(goto_6, goto_7))\n  set_bit_2_mid = or(or(goto_12, goto_13), or(goto_14, goto_15))\n  set_bit_2_high = or(or(or(goto_20, goto_21), goto_22), goto_23)\n  set_bit_2 = or(or(set_bit_2_low, set_bit_2_mid), set_bit_2_high)\n\n  ; Bit 3: set for states 8, 9, 10, 11, 12, 13, 14, 15\n  goto_8 = from_1_to_8\n  set_bit_3_low = or(or(goto_8, goto_9), or(goto_10, goto_11))\n  set_bit_3_high = or(or(goto_12, goto_13), or(goto_14, goto_15))\n  set_bit_3 = or(set_bit_3_low, set_bit_3_high)\n\n  ; Bit 4: set for states 16, 17, 18, 19, 20, 21, 22, 23\n  goto_16 = from_1_to_16\n  set_bit_4_rts = or(or(goto_16, goto_17), or(goto_18, goto_19))\n  set_bit_4_reset = or(or(or(goto_20, goto_21), goto_22), goto_23)\n  set_bit_4 = or(set_bit_4_rts, set_bit_4_reset)\n\n  ; Apply reset (goes to state 20 = 10100 to read reset vector)\n  ; During reset: bit0=0, bit1=0, bit2=1, bit3=0, bit4=1\n  next_state0 = and(set_bit_0, not(reset))\n  next_state1 = and(set_bit_1, not(reset))\n  next_state2 = or(and(set_bit_2, not(reset)), reset)  ; Set to 1 on reset\n  next_state3 = and(set_bit_3, not(reset))\n  next_state4 = or(and(set_bit_4, not(reset)), reset)  ; Set to 1 on reset\n  \n  ; ==========================================\n  ; Output Logic\n  ; ==========================================\n  ; Address bus:\n  ;   - PC during fetch states (0, 1, 2, 3, 4)\n  ;   - operand_addr during EXEC_ST (5) and EXEC_LOAD (23)\n  ;   - stack_addr during:\n  ;     - PHA: PUSH (8)\n  ;     - PLA: PULL_INC (9), PULL_READ (10)\n  ;     - JSR: JSR_PUSH_HI (12), JSR_PUSH_LO (14)\n  ;     - RTS: RTS_INC1 (16), RTS_PULL_LO (17), RTS_INC2 (18), RTS_PULL_HI (19)\n  ;           Need stack_addr during ALL RTS states so memory is setup before read\n  ;   - reset_vec_addr during RESET_LO (20) and RESET_HI (21)\n  operand_addr = concat(addr_hi, addr_lo)\n  is_stack_op_pha_pla = or(or(is_state_8, is_state_9), is_state_10)\n  is_stack_op_jsr = or(is_state_12, is_state_14)\n  is_stack_op_rts = or(or(or(is_state_16, is_state_17), is_state_18), is_state_19)\n  is_stack_op = or(or(is_stack_op_pha_pla, is_stack_op_jsr), is_stack_op_rts)\n  addr_store_or_stack = mux16(operand_addr, stack_addr, is_stack_op)\n  ; State 5 (EXEC_ST) and state 23 (EXEC_LOAD) both use operand_addr\n  is_operand_addr_state = or(is_state_5, is_state_23)\n  is_addr_not_pc = or(is_operand_addr_state, is_stack_op)\n  addr_before_reset = mux16(pc_out, addr_store_or_stack, is_addr_not_pc)\n\n  ; Reset vector addresses: $FFFC for low byte, $FFFD for high byte\n  ; $FFFC = 1111111111111100, $FFFD = 1111111111111101\n  reset_vec_lo = concat(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0)\n  reset_vec_hi = concat(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1)\n  is_reset_state = or(is_state_20, is_state_21)\n  reset_vec_addr = mux16(reset_vec_lo, reset_vec_hi, is_state_21)\n  addr = mux16(addr_before_reset, reset_vec_addr, is_reset_state)\n\n  ; Data out:\n  ;   - A register for STA/PHA\n  ;   - X register for STX\n  ;   - Y register for STY\n  ;   - PC[15:8] for JSR_PUSH_HI (state 12)\n  ;   - PC[7:0] for JSR_PUSH_LO (state 14)\n  ; Use nested mux: first select between A and X, then between that and Y, then for JSR\n  data_out_ax = mux8(a_out, x_out, dec.is_stx)\n  data_out_axy = mux8(data_out_ax, y_out, dec.is_sty)\n  ; Extract PC bytes for JSR push\n  pc_hi = pc_out[8:15]\n  pc_lo = pc_out[0:7]\n  ; Select between PC high and PC low based on which JSR state we're in\n  pc_byte_for_jsr = mux8(pc_hi, pc_lo, is_state_14)\n  ; Select between normal data (A/X/Y) and PC byte for JSR\n  is_jsr_push = or(is_state_12, is_state_14)\n  data_out = mux8(data_out_axy, pc_byte_for_jsr, is_jsr_push)\n\n  ; Memory write: during EXEC_ST (5), PUSH (8), JSR_PUSH_HI (12), JSR_PUSH_LO (14)\n  mem_write_store_pha = or(is_state_5, is_state_8)\n  mem_write_jsr = or(is_state_12, is_state_14)\n  mem_write = or(mem_write_store_pha, mem_write_jsr)\n\n  ; Halted output\n  halted = is_state_7\n\n  ; Debug outputs for reset vector troubleshooting\n  debug_reset_hi = reset_hi\n  debug_addr_lo = addr_lo\n  debug_is_state_20 = is_state_20\n  debug_is_state_21 = is_state_21\n  debug_is_state_22 = is_state_22\n  debug_addr_lo_load = addr_lo_load\n  debug_data_in = data_in\n  debug_pc_load = pc_load\n  debug_reset_target = reset_target\n",
  "wire/decoder.wire": "; Instruction Decoder for Minimal CPU\n; Decodes opcodes into control signals for 34 instructions\n;\n; Opcodes (authentic 6502):\n;   0xA9 = LDA #imm (2 bytes) = 10101001\n;   0xAD = LDA $addr (3 bytes) = 10101101\n;   0xA2 = LDX #imm (2 bytes) = 10100010\n;   0xAE = LDX $addr (3 bytes) = 10101110\n;   0xA0 = LDY #imm (2 bytes) = 10100000\n;   0xAC = LDY $addr (3 bytes) = 10101100\n;   0x69 = ADC #imm (2 bytes) = 01101001\n;   0xE9 = SBC #imm (2 bytes) = 11101001\n;   0xC9 = CMP #imm (2 bytes) = 11001001\n;   0x29 = AND #imm (2 bytes) = 00101001\n;   0x09 = ORA #imm (2 bytes) = 00001001\n;   0x49 = EOR #imm (2 bytes) = 01001001\n;   0x8D = STA $addr (3 bytes) = 10001101\n;   0x8E = STX $addr (3 bytes) = 10001110\n;   0x8C = STY $addr (3 bytes) = 10001100\n;   0x4C = JMP $addr (3 bytes) = 01001100\n;   0x20 = JSR $addr (3 bytes) = 00100000\n;   0x60 = RTS (1 byte) = 01100000\n;   0xF0 = BEQ rel (2 bytes) = 11110000\n;   0xD0 = BNE rel (2 bytes) = 11010000\n;   0xE8 = INX (1 byte) = 11101000\n;   0xCA = DEX (1 byte) = 11001010\n;   0xC8 = INY (1 byte) = 11001000\n;   0x88 = DEY (1 byte) = 10001000\n;   0xAA = TAX (1 byte) = 10101010\n;   0xA8 = TAY (1 byte) = 10101000\n;   0x8A = TXA (1 byte) = 10001010\n;   0x98 = TYA (1 byte) = 10011000\n;   0x48 = PHA (1 byte) = 01001000\n;   0x68 = PLA (1 byte) = 01101000\n;   0x9A = TXS (1 byte) = 10011010\n;   0x18 = CLC (1 byte) = 00011000\n;   0x38 = SEC (1 byte) = 00111000\n;   0x02 = HLT (1 byte) = 00000010\n;\n; Inputs:\n;   opcode:8  - Instruction opcode byte\n;\n; Outputs:\n;   is_lda    - Opcode is LDA #imm\n;   is_lda_abs - Opcode is LDA $addr\n;   is_ldx    - Opcode is LDX #imm\n;   is_ldx_abs - Opcode is LDX $addr\n;   is_ldy    - Opcode is LDY #imm\n;   is_ldy_abs - Opcode is LDY $addr\n;   is_adc    - Opcode is ADC #imm\n;   is_sbc    - Opcode is SBC #imm\n;   is_cmp    - Opcode is CMP #imm\n;   is_and    - Opcode is AND #imm\n;   is_ora    - Opcode is ORA #imm\n;   is_eor    - Opcode is EOR #imm\n;   is_sta    - Opcode is STA $addr\n;   is_stx    - Opcode is STX $addr\n;   is_sty    - Opcode is STY $addr\n;   is_jmp    - Opcode is JMP $addr\n;   is_beq    - Opcode is BEQ rel\n;   is_bne    - Opcode is BNE rel\n;   is_inx    - Opcode is INX\n;   is_dex    - Opcode is DEX\n;   is_iny    - Opcode is INY\n;   is_dey    - Opcode is DEY\n;   is_tax    - Opcode is TAX\n;   is_tay    - Opcode is TAY\n;   is_txa    - Opcode is TXA\n;   is_tya    - Opcode is TYA\n;   is_pha    - Opcode is PHA\n;   is_pla    - Opcode is PLA\n;   is_jsr    - Opcode is JSR\n;   is_rts    - Opcode is RTS\n;   is_txs    - Opcode is TXS\n;   is_clc    - Opcode is CLC\n;   is_sec    - Opcode is SEC\n;   is_hlt    - Opcode is HLT\n;   needs_imm - Instruction needs immediate operand (1 byte)\n;   needs_addr - Instruction needs address operand (2 bytes)\n;   needs_rel - Instruction needs relative offset (1 signed byte)\n;   is_implied - Instruction has no operand (1 byte total)\n\nmodule decoder(opcode:8) -> (is_lda, is_lda_abs, is_ldx, is_ldx_abs, is_ldy, is_ldy_abs, is_adc, is_sbc, is_cmp, is_and, is_ora, is_eor, is_sta, is_stx, is_sty, is_jmp, is_jsr, is_rts, is_beq, is_bne, is_inx, is_dex, is_iny, is_dey, is_tax, is_tay, is_txa, is_tya, is_pha, is_pla, is_txs, is_clc, is_sec, is_hlt, needs_imm, needs_addr, needs_rel, needs_load_addr, is_implied):\n  ; We need to compare opcode with specific values\n  ; XOR with target: if match, all bits will be 0\n  ; Then NOR-reduce to check if all bits are 0\n  \n  ; Helper: check if 8-bit value is all zeros (result is 1 if all zeros)\n  ; We'll use a NOR tree approach\n  \n  ; LDA #imm = 0xA9 = 10101001 binary\n  ; opcode[0]=1, [1]=0, [2]=0, [3]=1, [4]=0, [5]=1, [6]=0, [7]=1\n  lda_b0 = xor(opcode[0], 1)  ; bit 0 should be 1\n  lda_b1 = xor(opcode[1], 0)  ; bit 1 should be 0\n  lda_b2 = xor(opcode[2], 0)  ; bit 2 should be 0\n  lda_b3 = xor(opcode[3], 1)  ; bit 3 should be 1\n  lda_b4 = xor(opcode[4], 0)  ; bit 4 should be 0\n  lda_b5 = xor(opcode[5], 1)  ; bit 5 should be 1\n  lda_b6 = xor(opcode[6], 0)  ; bit 6 should be 0\n  lda_b7 = xor(opcode[7], 1)  ; bit 7 should be 1\n  ; If all XOR results are 0, we have a match\n  lda_any01 = or(lda_b0, lda_b1)\n  lda_any23 = or(lda_b2, lda_b3)\n  lda_any45 = or(lda_b4, lda_b5)\n  lda_any67 = or(lda_b6, lda_b7)\n  lda_any0123 = or(lda_any01, lda_any23)\n  lda_any4567 = or(lda_any45, lda_any67)\n  lda_any = or(lda_any0123, lda_any4567)\n  is_lda = not(lda_any)\n\n  ; LDX #imm = 0xA2 = 10100010 binary\n  ; opcode[0]=0, [1]=1, [2]=0, [3]=0, [4]=0, [5]=1, [6]=0, [7]=1\n  ldx_b0 = xor(opcode[0], 0)\n  ldx_b1 = xor(opcode[1], 1)\n  ldx_b2 = xor(opcode[2], 0)\n  ldx_b3 = xor(opcode[3], 0)\n  ldx_b4 = xor(opcode[4], 0)\n  ldx_b5 = xor(opcode[5], 1)\n  ldx_b6 = xor(opcode[6], 0)\n  ldx_b7 = xor(opcode[7], 1)\n  ldx_any01 = or(ldx_b0, ldx_b1)\n  ldx_any23 = or(ldx_b2, ldx_b3)\n  ldx_any45 = or(ldx_b4, ldx_b5)\n  ldx_any67 = or(ldx_b6, ldx_b7)\n  ldx_any0123 = or(ldx_any01, ldx_any23)\n  ldx_any4567 = or(ldx_any45, ldx_any67)\n  ldx_any = or(ldx_any0123, ldx_any4567)\n  is_ldx = not(ldx_any)\n\n  ; ADC #imm = 0x69 = 01101001 binary\n  ; opcode[0]=1, [1]=0, [2]=0, [3]=1, [4]=0, [5]=1, [6]=1, [7]=0\n  adc_b0 = xor(opcode[0], 1)\n  adc_b1 = xor(opcode[1], 0)\n  adc_b2 = xor(opcode[2], 0)\n  adc_b3 = xor(opcode[3], 1)\n  adc_b4 = xor(opcode[4], 0)\n  adc_b5 = xor(opcode[5], 1)\n  adc_b6 = xor(opcode[6], 1)\n  adc_b7 = xor(opcode[7], 0)\n  adc_any01 = or(adc_b0, adc_b1)\n  adc_any23 = or(adc_b2, adc_b3)\n  adc_any45 = or(adc_b4, adc_b5)\n  adc_any67 = or(adc_b6, adc_b7)\n  adc_any0123 = or(adc_any01, adc_any23)\n  adc_any4567 = or(adc_any45, adc_any67)\n  adc_any = or(adc_any0123, adc_any4567)\n  is_adc = not(adc_any)\n\n  ; STA $addr = 0x8D = 10001101 binary\n  ; opcode[0]=1, [1]=0, [2]=1, [3]=1, [4]=0, [5]=0, [6]=0, [7]=1\n  sta_b0 = xor(opcode[0], 1)\n  sta_b1 = xor(opcode[1], 0)\n  sta_b2 = xor(opcode[2], 1)\n  sta_b3 = xor(opcode[3], 1)\n  sta_b4 = xor(opcode[4], 0)\n  sta_b5 = xor(opcode[5], 0)\n  sta_b6 = xor(opcode[6], 0)\n  sta_b7 = xor(opcode[7], 1)\n  sta_any01 = or(sta_b0, sta_b1)\n  sta_any23 = or(sta_b2, sta_b3)\n  sta_any45 = or(sta_b4, sta_b5)\n  sta_any67 = or(sta_b6, sta_b7)\n  sta_any0123 = or(sta_any01, sta_any23)\n  sta_any4567 = or(sta_any45, sta_any67)\n  sta_any = or(sta_any0123, sta_any4567)\n  is_sta = not(sta_any)\n\n  ; JMP $addr = 0x4C = 01001100 binary\n  ; opcode[0]=0, [1]=0, [2]=1, [3]=1, [4]=0, [5]=0, [6]=1, [7]=0\n  jmp_b0 = xor(opcode[0], 0)\n  jmp_b1 = xor(opcode[1], 0)\n  jmp_b2 = xor(opcode[2], 1)\n  jmp_b3 = xor(opcode[3], 1)\n  jmp_b4 = xor(opcode[4], 0)\n  jmp_b5 = xor(opcode[5], 0)\n  jmp_b6 = xor(opcode[6], 1)\n  jmp_b7 = xor(opcode[7], 0)\n  jmp_any01 = or(jmp_b0, jmp_b1)\n  jmp_any23 = or(jmp_b2, jmp_b3)\n  jmp_any45 = or(jmp_b4, jmp_b5)\n  jmp_any67 = or(jmp_b6, jmp_b7)\n  jmp_any0123 = or(jmp_any01, jmp_any23)\n  jmp_any4567 = or(jmp_any45, jmp_any67)\n  jmp_any = or(jmp_any0123, jmp_any4567)\n  is_jmp = not(jmp_any)\n\n  ; BEQ rel = 0xF0 = 11110000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=0, [4]=1, [5]=1, [6]=1, [7]=1\n  beq_b0 = xor(opcode[0], 0)\n  beq_b1 = xor(opcode[1], 0)\n  beq_b2 = xor(opcode[2], 0)\n  beq_b3 = xor(opcode[3], 0)\n  beq_b4 = xor(opcode[4], 1)\n  beq_b5 = xor(opcode[5], 1)\n  beq_b6 = xor(opcode[6], 1)\n  beq_b7 = xor(opcode[7], 1)\n  beq_any01 = or(beq_b0, beq_b1)\n  beq_any23 = or(beq_b2, beq_b3)\n  beq_any45 = or(beq_b4, beq_b5)\n  beq_any67 = or(beq_b6, beq_b7)\n  beq_any0123 = or(beq_any01, beq_any23)\n  beq_any4567 = or(beq_any45, beq_any67)\n  beq_any = or(beq_any0123, beq_any4567)\n  is_beq = not(beq_any)\n\n  ; HLT = 0x02 = 00000010 binary\n  ; opcode[0]=0, [1]=1, [2]=0, [3]=0, [4]=0, [5]=0, [6]=0, [7]=0\n  hlt_b0 = xor(opcode[0], 0)\n  hlt_b1 = xor(opcode[1], 1)\n  hlt_b2 = xor(opcode[2], 0)\n  hlt_b3 = xor(opcode[3], 0)\n  hlt_b4 = xor(opcode[4], 0)\n  hlt_b5 = xor(opcode[5], 0)\n  hlt_b6 = xor(opcode[6], 0)\n  hlt_b7 = xor(opcode[7], 0)\n  hlt_any01 = or(hlt_b0, hlt_b1)\n  hlt_any23 = or(hlt_b2, hlt_b3)\n  hlt_any45 = or(hlt_b4, hlt_b5)\n  hlt_any67 = or(hlt_b6, hlt_b7)\n  hlt_any0123 = or(hlt_any01, hlt_any23)\n  hlt_any4567 = or(hlt_any45, hlt_any67)\n  hlt_any = or(hlt_any0123, hlt_any4567)\n  is_hlt = not(hlt_any)\n\n  ; SBC #imm = 0xE9 = 11101001 binary\n  ; opcode[0]=1, [1]=0, [2]=0, [3]=1, [4]=0, [5]=1, [6]=1, [7]=1\n  sbc_b0 = xor(opcode[0], 1)\n  sbc_b1 = xor(opcode[1], 0)\n  sbc_b2 = xor(opcode[2], 0)\n  sbc_b3 = xor(opcode[3], 1)\n  sbc_b4 = xor(opcode[4], 0)\n  sbc_b5 = xor(opcode[5], 1)\n  sbc_b6 = xor(opcode[6], 1)\n  sbc_b7 = xor(opcode[7], 1)\n  sbc_any01 = or(sbc_b0, sbc_b1)\n  sbc_any23 = or(sbc_b2, sbc_b3)\n  sbc_any45 = or(sbc_b4, sbc_b5)\n  sbc_any67 = or(sbc_b6, sbc_b7)\n  sbc_any0123 = or(sbc_any01, sbc_any23)\n  sbc_any4567 = or(sbc_any45, sbc_any67)\n  sbc_any = or(sbc_any0123, sbc_any4567)\n  is_sbc = not(sbc_any)\n\n  ; STX $addr = 0x8E = 10001110 binary\n  ; opcode[0]=0, [1]=1, [2]=1, [3]=1, [4]=0, [5]=0, [6]=0, [7]=1\n  stx_b0 = xor(opcode[0], 0)\n  stx_b1 = xor(opcode[1], 1)\n  stx_b2 = xor(opcode[2], 1)\n  stx_b3 = xor(opcode[3], 1)\n  stx_b4 = xor(opcode[4], 0)\n  stx_b5 = xor(opcode[5], 0)\n  stx_b6 = xor(opcode[6], 0)\n  stx_b7 = xor(opcode[7], 1)\n  stx_any01 = or(stx_b0, stx_b1)\n  stx_any23 = or(stx_b2, stx_b3)\n  stx_any45 = or(stx_b4, stx_b5)\n  stx_any67 = or(stx_b6, stx_b7)\n  stx_any0123 = or(stx_any01, stx_any23)\n  stx_any4567 = or(stx_any45, stx_any67)\n  stx_any = or(stx_any0123, stx_any4567)\n  is_stx = not(stx_any)\n\n  ; BNE rel = 0xD0 = 11010000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=0, [4]=1, [5]=0, [6]=1, [7]=1\n  bne_b0 = xor(opcode[0], 0)\n  bne_b1 = xor(opcode[1], 0)\n  bne_b2 = xor(opcode[2], 0)\n  bne_b3 = xor(opcode[3], 0)\n  bne_b4 = xor(opcode[4], 1)\n  bne_b5 = xor(opcode[5], 0)\n  bne_b6 = xor(opcode[6], 1)\n  bne_b7 = xor(opcode[7], 1)\n  bne_any01 = or(bne_b0, bne_b1)\n  bne_any23 = or(bne_b2, bne_b3)\n  bne_any45 = or(bne_b4, bne_b5)\n  bne_any67 = or(bne_b6, bne_b7)\n  bne_any0123 = or(bne_any01, bne_any23)\n  bne_any4567 = or(bne_any45, bne_any67)\n  bne_any = or(bne_any0123, bne_any4567)\n  is_bne = not(bne_any)\n\n  ; CMP #imm = 0xC9 = 11001001 binary\n  ; opcode[0]=1, [1]=0, [2]=0, [3]=1, [4]=0, [5]=0, [6]=1, [7]=1\n  cmp_b0 = xor(opcode[0], 1)\n  cmp_b1 = xor(opcode[1], 0)\n  cmp_b2 = xor(opcode[2], 0)\n  cmp_b3 = xor(opcode[3], 1)\n  cmp_b4 = xor(opcode[4], 0)\n  cmp_b5 = xor(opcode[5], 0)\n  cmp_b6 = xor(opcode[6], 1)\n  cmp_b7 = xor(opcode[7], 1)\n  cmp_any01 = or(cmp_b0, cmp_b1)\n  cmp_any23 = or(cmp_b2, cmp_b3)\n  cmp_any45 = or(cmp_b4, cmp_b5)\n  cmp_any67 = or(cmp_b6, cmp_b7)\n  cmp_any0123 = or(cmp_any01, cmp_any23)\n  cmp_any4567 = or(cmp_any45, cmp_any67)\n  cmp_any = or(cmp_any0123, cmp_any4567)\n  is_cmp = not(cmp_any)\n\n  ; INX = 0xE8 = 11101000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=1, [4]=0, [5]=1, [6]=1, [7]=1\n  inx_b0 = xor(opcode[0], 0)\n  inx_b1 = xor(opcode[1], 0)\n  inx_b2 = xor(opcode[2], 0)\n  inx_b3 = xor(opcode[3], 1)\n  inx_b4 = xor(opcode[4], 0)\n  inx_b5 = xor(opcode[5], 1)\n  inx_b6 = xor(opcode[6], 1)\n  inx_b7 = xor(opcode[7], 1)\n  inx_any01 = or(inx_b0, inx_b1)\n  inx_any23 = or(inx_b2, inx_b3)\n  inx_any45 = or(inx_b4, inx_b5)\n  inx_any67 = or(inx_b6, inx_b7)\n  inx_any0123 = or(inx_any01, inx_any23)\n  inx_any4567 = or(inx_any45, inx_any67)\n  inx_any = or(inx_any0123, inx_any4567)\n  is_inx = not(inx_any)\n\n  ; DEX = 0xCA = 11001010 binary\n  ; opcode[0]=0, [1]=1, [2]=0, [3]=1, [4]=0, [5]=0, [6]=1, [7]=1\n  dex_b0 = xor(opcode[0], 0)\n  dex_b1 = xor(opcode[1], 1)\n  dex_b2 = xor(opcode[2], 0)\n  dex_b3 = xor(opcode[3], 1)\n  dex_b4 = xor(opcode[4], 0)\n  dex_b5 = xor(opcode[5], 0)\n  dex_b6 = xor(opcode[6], 1)\n  dex_b7 = xor(opcode[7], 1)\n  dex_any01 = or(dex_b0, dex_b1)\n  dex_any23 = or(dex_b2, dex_b3)\n  dex_any45 = or(dex_b4, dex_b5)\n  dex_any67 = or(dex_b6, dex_b7)\n  dex_any0123 = or(dex_any01, dex_any23)\n  dex_any4567 = or(dex_any45, dex_any67)\n  dex_any = or(dex_any0123, dex_any4567)\n  is_dex = not(dex_any)\n\n  ; AND #imm = 0x29 = 00101001 binary\n  ; opcode[0]=1, [1]=0, [2]=0, [3]=1, [4]=0, [5]=1, [6]=0, [7]=0\n  and_b0 = xor(opcode[0], 1)\n  and_b1 = xor(opcode[1], 0)\n  and_b2 = xor(opcode[2], 0)\n  and_b3 = xor(opcode[3], 1)\n  and_b4 = xor(opcode[4], 0)\n  and_b5 = xor(opcode[5], 1)\n  and_b6 = xor(opcode[6], 0)\n  and_b7 = xor(opcode[7], 0)\n  and_any01 = or(and_b0, and_b1)\n  and_any23 = or(and_b2, and_b3)\n  and_any45 = or(and_b4, and_b5)\n  and_any67 = or(and_b6, and_b7)\n  and_any0123 = or(and_any01, and_any23)\n  and_any4567 = or(and_any45, and_any67)\n  and_any = or(and_any0123, and_any4567)\n  is_and = not(and_any)\n\n  ; ORA #imm = 0x09 = 00001001 binary\n  ; opcode[0]=1, [1]=0, [2]=0, [3]=1, [4]=0, [5]=0, [6]=0, [7]=0\n  ora_b0 = xor(opcode[0], 1)\n  ora_b1 = xor(opcode[1], 0)\n  ora_b2 = xor(opcode[2], 0)\n  ora_b3 = xor(opcode[3], 1)\n  ora_b4 = xor(opcode[4], 0)\n  ora_b5 = xor(opcode[5], 0)\n  ora_b6 = xor(opcode[6], 0)\n  ora_b7 = xor(opcode[7], 0)\n  ora_any01 = or(ora_b0, ora_b1)\n  ora_any23 = or(ora_b2, ora_b3)\n  ora_any45 = or(ora_b4, ora_b5)\n  ora_any67 = or(ora_b6, ora_b7)\n  ora_any0123 = or(ora_any01, ora_any23)\n  ora_any4567 = or(ora_any45, ora_any67)\n  ora_any = or(ora_any0123, ora_any4567)\n  is_ora = not(ora_any)\n\n  ; EOR #imm = 0x49 = 01001001 binary\n  ; opcode[0]=1, [1]=0, [2]=0, [3]=1, [4]=0, [5]=0, [6]=1, [7]=0\n  eor_b0 = xor(opcode[0], 1)\n  eor_b1 = xor(opcode[1], 0)\n  eor_b2 = xor(opcode[2], 0)\n  eor_b3 = xor(opcode[3], 1)\n  eor_b4 = xor(opcode[4], 0)\n  eor_b5 = xor(opcode[5], 0)\n  eor_b6 = xor(opcode[6], 1)\n  eor_b7 = xor(opcode[7], 0)\n  eor_any01 = or(eor_b0, eor_b1)\n  eor_any23 = or(eor_b2, eor_b3)\n  eor_any45 = or(eor_b4, eor_b5)\n  eor_any67 = or(eor_b6, eor_b7)\n  eor_any0123 = or(eor_any01, eor_any23)\n  eor_any4567 = or(eor_any45, eor_any67)\n  eor_any = or(eor_any0123, eor_any4567)\n  is_eor = not(eor_any)\n\n  ; LDY #imm = 0xA0 = 10100000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=0, [4]=0, [5]=1, [6]=0, [7]=1\n  ldy_b0 = xor(opcode[0], 0)\n  ldy_b1 = xor(opcode[1], 0)\n  ldy_b2 = xor(opcode[2], 0)\n  ldy_b3 = xor(opcode[3], 0)\n  ldy_b4 = xor(opcode[4], 0)\n  ldy_b5 = xor(opcode[5], 1)\n  ldy_b6 = xor(opcode[6], 0)\n  ldy_b7 = xor(opcode[7], 1)\n  ldy_any01 = or(ldy_b0, ldy_b1)\n  ldy_any23 = or(ldy_b2, ldy_b3)\n  ldy_any45 = or(ldy_b4, ldy_b5)\n  ldy_any67 = or(ldy_b6, ldy_b7)\n  ldy_any0123 = or(ldy_any01, ldy_any23)\n  ldy_any4567 = or(ldy_any45, ldy_any67)\n  ldy_any = or(ldy_any0123, ldy_any4567)\n  is_ldy = not(ldy_any)\n\n  ; STY $addr = 0x8C = 10001100 binary\n  ; opcode[0]=0, [1]=0, [2]=1, [3]=1, [4]=0, [5]=0, [6]=0, [7]=1\n  sty_b0 = xor(opcode[0], 0)\n  sty_b1 = xor(opcode[1], 0)\n  sty_b2 = xor(opcode[2], 1)\n  sty_b3 = xor(opcode[3], 1)\n  sty_b4 = xor(opcode[4], 0)\n  sty_b5 = xor(opcode[5], 0)\n  sty_b6 = xor(opcode[6], 0)\n  sty_b7 = xor(opcode[7], 1)\n  sty_any01 = or(sty_b0, sty_b1)\n  sty_any23 = or(sty_b2, sty_b3)\n  sty_any45 = or(sty_b4, sty_b5)\n  sty_any67 = or(sty_b6, sty_b7)\n  sty_any0123 = or(sty_any01, sty_any23)\n  sty_any4567 = or(sty_any45, sty_any67)\n  sty_any = or(sty_any0123, sty_any4567)\n  is_sty = not(sty_any)\n\n  ; INY = 0xC8 = 11001000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=1, [4]=0, [5]=0, [6]=1, [7]=1\n  iny_b0 = xor(opcode[0], 0)\n  iny_b1 = xor(opcode[1], 0)\n  iny_b2 = xor(opcode[2], 0)\n  iny_b3 = xor(opcode[3], 1)\n  iny_b4 = xor(opcode[4], 0)\n  iny_b5 = xor(opcode[5], 0)\n  iny_b6 = xor(opcode[6], 1)\n  iny_b7 = xor(opcode[7], 1)\n  iny_any01 = or(iny_b0, iny_b1)\n  iny_any23 = or(iny_b2, iny_b3)\n  iny_any45 = or(iny_b4, iny_b5)\n  iny_any67 = or(iny_b6, iny_b7)\n  iny_any0123 = or(iny_any01, iny_any23)\n  iny_any4567 = or(iny_any45, iny_any67)\n  iny_any = or(iny_any0123, iny_any4567)\n  is_iny = not(iny_any)\n\n  ; DEY = 0x88 = 10001000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=1, [4]=0, [5]=0, [6]=0, [7]=1\n  dey_b0 = xor(opcode[0], 0)\n  dey_b1 = xor(opcode[1], 0)\n  dey_b2 = xor(opcode[2], 0)\n  dey_b3 = xor(opcode[3], 1)\n  dey_b4 = xor(opcode[4], 0)\n  dey_b5 = xor(opcode[5], 0)\n  dey_b6 = xor(opcode[6], 0)\n  dey_b7 = xor(opcode[7], 1)\n  dey_any01 = or(dey_b0, dey_b1)\n  dey_any23 = or(dey_b2, dey_b3)\n  dey_any45 = or(dey_b4, dey_b5)\n  dey_any67 = or(dey_b6, dey_b7)\n  dey_any0123 = or(dey_any01, dey_any23)\n  dey_any4567 = or(dey_any45, dey_any67)\n  dey_any = or(dey_any0123, dey_any4567)\n  is_dey = not(dey_any)\n\n  ; TAX = 0xAA = 10101010 binary\n  ; opcode[0]=0, [1]=1, [2]=0, [3]=1, [4]=0, [5]=1, [6]=0, [7]=1\n  tax_b0 = xor(opcode[0], 0)\n  tax_b1 = xor(opcode[1], 1)\n  tax_b2 = xor(opcode[2], 0)\n  tax_b3 = xor(opcode[3], 1)\n  tax_b4 = xor(opcode[4], 0)\n  tax_b5 = xor(opcode[5], 1)\n  tax_b6 = xor(opcode[6], 0)\n  tax_b7 = xor(opcode[7], 1)\n  tax_any01 = or(tax_b0, tax_b1)\n  tax_any23 = or(tax_b2, tax_b3)\n  tax_any45 = or(tax_b4, tax_b5)\n  tax_any67 = or(tax_b6, tax_b7)\n  tax_any0123 = or(tax_any01, tax_any23)\n  tax_any4567 = or(tax_any45, tax_any67)\n  tax_any = or(tax_any0123, tax_any4567)\n  is_tax = not(tax_any)\n\n  ; TAY = 0xA8 = 10101000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=1, [4]=0, [5]=1, [6]=0, [7]=1\n  tay_b0 = xor(opcode[0], 0)\n  tay_b1 = xor(opcode[1], 0)\n  tay_b2 = xor(opcode[2], 0)\n  tay_b3 = xor(opcode[3], 1)\n  tay_b4 = xor(opcode[4], 0)\n  tay_b5 = xor(opcode[5], 1)\n  tay_b6 = xor(opcode[6], 0)\n  tay_b7 = xor(opcode[7], 1)\n  tay_any01 = or(tay_b0, tay_b1)\n  tay_any23 = or(tay_b2, tay_b3)\n  tay_any45 = or(tay_b4, tay_b5)\n  tay_any67 = or(tay_b6, tay_b7)\n  tay_any0123 = or(tay_any01, tay_any23)\n  tay_any4567 = or(tay_any45, tay_any67)\n  tay_any = or(tay_any0123, tay_any4567)\n  is_tay = not(tay_any)\n\n  ; TXA = 0x8A = 10001010 binary\n  ; opcode[0]=0, [1]=1, [2]=0, [3]=1, [4]=0, [5]=0, [6]=0, [7]=1\n  txa_b0 = xor(opcode[0], 0)\n  txa_b1 = xor(opcode[1], 1)\n  txa_b2 = xor(opcode[2], 0)\n  txa_b3 = xor(opcode[3], 1)\n  txa_b4 = xor(opcode[4], 0)\n  txa_b5 = xor(opcode[5], 0)\n  txa_b6 = xor(opcode[6], 0)\n  txa_b7 = xor(opcode[7], 1)\n  txa_any01 = or(txa_b0, txa_b1)\n  txa_any23 = or(txa_b2, txa_b3)\n  txa_any45 = or(txa_b4, txa_b5)\n  txa_any67 = or(txa_b6, txa_b7)\n  txa_any0123 = or(txa_any01, txa_any23)\n  txa_any4567 = or(txa_any45, txa_any67)\n  txa_any = or(txa_any0123, txa_any4567)\n  is_txa = not(txa_any)\n\n  ; TYA = 0x98 = 10011000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=1, [4]=1, [5]=0, [6]=0, [7]=1\n  tya_b0 = xor(opcode[0], 0)\n  tya_b1 = xor(opcode[1], 0)\n  tya_b2 = xor(opcode[2], 0)\n  tya_b3 = xor(opcode[3], 1)\n  tya_b4 = xor(opcode[4], 1)\n  tya_b5 = xor(opcode[5], 0)\n  tya_b6 = xor(opcode[6], 0)\n  tya_b7 = xor(opcode[7], 1)\n  tya_any01 = or(tya_b0, tya_b1)\n  tya_any23 = or(tya_b2, tya_b3)\n  tya_any45 = or(tya_b4, tya_b5)\n  tya_any67 = or(tya_b6, tya_b7)\n  tya_any0123 = or(tya_any01, tya_any23)\n  tya_any4567 = or(tya_any45, tya_any67)\n  tya_any = or(tya_any0123, tya_any4567)\n  is_tya = not(tya_any)\n\n  ; PHA = 0x48 = 01001000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=1, [4]=0, [5]=0, [6]=1, [7]=0\n  pha_b0 = xor(opcode[0], 0)\n  pha_b1 = xor(opcode[1], 0)\n  pha_b2 = xor(opcode[2], 0)\n  pha_b3 = xor(opcode[3], 1)\n  pha_b4 = xor(opcode[4], 0)\n  pha_b5 = xor(opcode[5], 0)\n  pha_b6 = xor(opcode[6], 1)\n  pha_b7 = xor(opcode[7], 0)\n  pha_any01 = or(pha_b0, pha_b1)\n  pha_any23 = or(pha_b2, pha_b3)\n  pha_any45 = or(pha_b4, pha_b5)\n  pha_any67 = or(pha_b6, pha_b7)\n  pha_any0123 = or(pha_any01, pha_any23)\n  pha_any4567 = or(pha_any45, pha_any67)\n  pha_any = or(pha_any0123, pha_any4567)\n  is_pha = not(pha_any)\n\n  ; PLA = 0x68 = 01101000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=1, [4]=0, [5]=1, [6]=1, [7]=0\n  pla_b0 = xor(opcode[0], 0)\n  pla_b1 = xor(opcode[1], 0)\n  pla_b2 = xor(opcode[2], 0)\n  pla_b3 = xor(opcode[3], 1)\n  pla_b4 = xor(opcode[4], 0)\n  pla_b5 = xor(opcode[5], 1)\n  pla_b6 = xor(opcode[6], 1)\n  pla_b7 = xor(opcode[7], 0)\n  pla_any01 = or(pla_b0, pla_b1)\n  pla_any23 = or(pla_b2, pla_b3)\n  pla_any45 = or(pla_b4, pla_b5)\n  pla_any67 = or(pla_b6, pla_b7)\n  pla_any0123 = or(pla_any01, pla_any23)\n  pla_any4567 = or(pla_any45, pla_any67)\n  pla_any = or(pla_any0123, pla_any4567)\n  is_pla = not(pla_any)\n\n  ; JSR $addr = 0x20 = 00100000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=0, [4]=0, [5]=1, [6]=0, [7]=0\n  jsr_b0 = xor(opcode[0], 0)\n  jsr_b1 = xor(opcode[1], 0)\n  jsr_b2 = xor(opcode[2], 0)\n  jsr_b3 = xor(opcode[3], 0)\n  jsr_b4 = xor(opcode[4], 0)\n  jsr_b5 = xor(opcode[5], 1)\n  jsr_b6 = xor(opcode[6], 0)\n  jsr_b7 = xor(opcode[7], 0)\n  jsr_any01 = or(jsr_b0, jsr_b1)\n  jsr_any23 = or(jsr_b2, jsr_b3)\n  jsr_any45 = or(jsr_b4, jsr_b5)\n  jsr_any67 = or(jsr_b6, jsr_b7)\n  jsr_any0123 = or(jsr_any01, jsr_any23)\n  jsr_any4567 = or(jsr_any45, jsr_any67)\n  jsr_any = or(jsr_any0123, jsr_any4567)\n  is_jsr = not(jsr_any)\n\n  ; RTS = 0x60 = 01100000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=0, [4]=0, [5]=1, [6]=1, [7]=0\n  rts_b0 = xor(opcode[0], 0)\n  rts_b1 = xor(opcode[1], 0)\n  rts_b2 = xor(opcode[2], 0)\n  rts_b3 = xor(opcode[3], 0)\n  rts_b4 = xor(opcode[4], 0)\n  rts_b5 = xor(opcode[5], 1)\n  rts_b6 = xor(opcode[6], 1)\n  rts_b7 = xor(opcode[7], 0)\n  rts_any01 = or(rts_b0, rts_b1)\n  rts_any23 = or(rts_b2, rts_b3)\n  rts_any45 = or(rts_b4, rts_b5)\n  rts_any67 = or(rts_b6, rts_b7)\n  rts_any0123 = or(rts_any01, rts_any23)\n  rts_any4567 = or(rts_any45, rts_any67)\n  rts_any = or(rts_any0123, rts_any4567)\n  is_rts = not(rts_any)\n\n  ; LDA abs = 0xAD = 10101101 binary\n  ; opcode[0]=1, [1]=0, [2]=1, [3]=1, [4]=0, [5]=1, [6]=0, [7]=1\n  lda_abs_b0 = xor(opcode[0], 1)\n  lda_abs_b1 = xor(opcode[1], 0)\n  lda_abs_b2 = xor(opcode[2], 1)\n  lda_abs_b3 = xor(opcode[3], 1)\n  lda_abs_b4 = xor(opcode[4], 0)\n  lda_abs_b5 = xor(opcode[5], 1)\n  lda_abs_b6 = xor(opcode[6], 0)\n  lda_abs_b7 = xor(opcode[7], 1)\n  lda_abs_any01 = or(lda_abs_b0, lda_abs_b1)\n  lda_abs_any23 = or(lda_abs_b2, lda_abs_b3)\n  lda_abs_any45 = or(lda_abs_b4, lda_abs_b5)\n  lda_abs_any67 = or(lda_abs_b6, lda_abs_b7)\n  lda_abs_any0123 = or(lda_abs_any01, lda_abs_any23)\n  lda_abs_any4567 = or(lda_abs_any45, lda_abs_any67)\n  lda_abs_any = or(lda_abs_any0123, lda_abs_any4567)\n  is_lda_abs = not(lda_abs_any)\n\n  ; LDX abs = 0xAE = 10101110 binary\n  ; opcode[0]=0, [1]=1, [2]=1, [3]=1, [4]=0, [5]=1, [6]=0, [7]=1\n  ldx_abs_b0 = xor(opcode[0], 0)\n  ldx_abs_b1 = xor(opcode[1], 1)\n  ldx_abs_b2 = xor(opcode[2], 1)\n  ldx_abs_b3 = xor(opcode[3], 1)\n  ldx_abs_b4 = xor(opcode[4], 0)\n  ldx_abs_b5 = xor(opcode[5], 1)\n  ldx_abs_b6 = xor(opcode[6], 0)\n  ldx_abs_b7 = xor(opcode[7], 1)\n  ldx_abs_any01 = or(ldx_abs_b0, ldx_abs_b1)\n  ldx_abs_any23 = or(ldx_abs_b2, ldx_abs_b3)\n  ldx_abs_any45 = or(ldx_abs_b4, ldx_abs_b5)\n  ldx_abs_any67 = or(ldx_abs_b6, ldx_abs_b7)\n  ldx_abs_any0123 = or(ldx_abs_any01, ldx_abs_any23)\n  ldx_abs_any4567 = or(ldx_abs_any45, ldx_abs_any67)\n  ldx_abs_any = or(ldx_abs_any0123, ldx_abs_any4567)\n  is_ldx_abs = not(ldx_abs_any)\n\n  ; LDY abs = 0xAC = 10101100 binary\n  ; opcode[0]=0, [1]=0, [2]=1, [3]=1, [4]=0, [5]=1, [6]=0, [7]=1\n  ldy_abs_b0 = xor(opcode[0], 0)\n  ldy_abs_b1 = xor(opcode[1], 0)\n  ldy_abs_b2 = xor(opcode[2], 1)\n  ldy_abs_b3 = xor(opcode[3], 1)\n  ldy_abs_b4 = xor(opcode[4], 0)\n  ldy_abs_b5 = xor(opcode[5], 1)\n  ldy_abs_b6 = xor(opcode[6], 0)\n  ldy_abs_b7 = xor(opcode[7], 1)\n  ldy_abs_any01 = or(ldy_abs_b0, ldy_abs_b1)\n  ldy_abs_any23 = or(ldy_abs_b2, ldy_abs_b3)\n  ldy_abs_any45 = or(ldy_abs_b4, ldy_abs_b5)\n  ldy_abs_any67 = or(ldy_abs_b6, ldy_abs_b7)\n  ldy_abs_any0123 = or(ldy_abs_any01, ldy_abs_any23)\n  ldy_abs_any4567 = or(ldy_abs_any45, ldy_abs_any67)\n  ldy_abs_any = or(ldy_abs_any0123, ldy_abs_any4567)\n  is_ldy_abs = not(ldy_abs_any)\n\n  ; TXS = 0x9A = 10011010 binary\n  ; opcode[0]=0, [1]=1, [2]=0, [3]=1, [4]=1, [5]=0, [6]=0, [7]=1\n  txs_b0 = xor(opcode[0], 0)\n  txs_b1 = xor(opcode[1], 1)\n  txs_b2 = xor(opcode[2], 0)\n  txs_b3 = xor(opcode[3], 1)\n  txs_b4 = xor(opcode[4], 1)\n  txs_b5 = xor(opcode[5], 0)\n  txs_b6 = xor(opcode[6], 0)\n  txs_b7 = xor(opcode[7], 1)\n  txs_any01 = or(txs_b0, txs_b1)\n  txs_any23 = or(txs_b2, txs_b3)\n  txs_any45 = or(txs_b4, txs_b5)\n  txs_any67 = or(txs_b6, txs_b7)\n  txs_any0123 = or(txs_any01, txs_any23)\n  txs_any4567 = or(txs_any45, txs_any67)\n  txs_any = or(txs_any0123, txs_any4567)\n  is_txs = not(txs_any)\n\n  ; CLC = 0x18 = 00011000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=1, [4]=1, [5]=0, [6]=0, [7]=0\n  clc_b0 = xor(opcode[0], 0)\n  clc_b1 = xor(opcode[1], 0)\n  clc_b2 = xor(opcode[2], 0)\n  clc_b3 = xor(opcode[3], 1)\n  clc_b4 = xor(opcode[4], 1)\n  clc_b5 = xor(opcode[5], 0)\n  clc_b6 = xor(opcode[6], 0)\n  clc_b7 = xor(opcode[7], 0)\n  clc_any01 = or(clc_b0, clc_b1)\n  clc_any23 = or(clc_b2, clc_b3)\n  clc_any45 = or(clc_b4, clc_b5)\n  clc_any67 = or(clc_b6, clc_b7)\n  clc_any0123 = or(clc_any01, clc_any23)\n  clc_any4567 = or(clc_any45, clc_any67)\n  clc_any = or(clc_any0123, clc_any4567)\n  is_clc = not(clc_any)\n\n  ; SEC = 0x38 = 00111000 binary\n  ; opcode[0]=0, [1]=0, [2]=0, [3]=1, [4]=1, [5]=1, [6]=0, [7]=0\n  sec_b0 = xor(opcode[0], 0)\n  sec_b1 = xor(opcode[1], 0)\n  sec_b2 = xor(opcode[2], 0)\n  sec_b3 = xor(opcode[3], 1)\n  sec_b4 = xor(opcode[4], 1)\n  sec_b5 = xor(opcode[5], 1)\n  sec_b6 = xor(opcode[6], 0)\n  sec_b7 = xor(opcode[7], 0)\n  sec_any01 = or(sec_b0, sec_b1)\n  sec_any23 = or(sec_b2, sec_b3)\n  sec_any45 = or(sec_b4, sec_b5)\n  sec_any67 = or(sec_b6, sec_b7)\n  sec_any0123 = or(sec_any01, sec_any23)\n  sec_any4567 = or(sec_any45, sec_any67)\n  sec_any = or(sec_any0123, sec_any4567)\n  is_sec = not(sec_any)\n\n  ; needs_imm: LDA, LDX, LDY, ADC, SBC, CMP, AND, ORA, EOR need immediate byte\n  is_logic_op = or(or(is_and, is_ora), is_eor)\n  is_load_imm = or(or(is_lda, is_ldx), is_ldy)\n  needs_imm = or(or(or(or(is_load_imm, is_adc), is_sbc), is_cmp), is_logic_op)\n\n  ; needs_addr: STA, STX, STY, JMP, and JSR need 16-bit address (for writes/jumps)\n  is_store = or(or(is_sta, is_stx), is_sty)\n  is_jump_or_call = or(is_jmp, is_jsr)\n  needs_addr = or(is_store, is_jump_or_call)\n\n  ; needs_load_addr: LDA abs, LDX abs, LDY abs need 16-bit address (for reads)\n  is_load_abs = or(or(is_lda_abs, is_ldx_abs), is_ldy_abs)\n  needs_load_addr = is_load_abs\n\n  ; needs_rel: BEQ and BNE need relative offset (1 signed byte)\n  needs_rel = or(is_beq, is_bne)\n\n  ; is_implied: HLT, INX, DEX, INY, DEY, TAX, TAY, TXA, TYA, PHA, PLA, RTS, TXS, CLC, SEC have no operand\n  is_inc_dec_x = or(is_inx, is_dex)\n  is_inc_dec_y = or(is_iny, is_dey)\n  is_transfer = or(or(is_tax, is_tay), or(is_txa, is_tya))\n  is_stack = or(is_pha, is_pla)\n  is_flag_op = or(is_clc, is_sec)\n  is_implied_basic = or(or(or(or(or(is_hlt, is_inc_dec_x), is_inc_dec_y), is_transfer), is_stack), is_rts)\n  is_implied = or(or(is_implied_basic, is_txs), is_flag_op)\n",
  "wire/gates.wire": "; Wire Standard Library - Basic Gates\n; All gates built from NAND primitives\n\n; NOT gate - inverts input\nmodule not(a) -> out:\n  out = nand(a, a)\n\n; AND gate - output high when both inputs high\nmodule and(a, b) -> out:\n  n = nand(a, b)\n  out = nand(n, n)\n\n; OR gate - output high when either input high\nmodule or(a, b) -> out:\n  na = nand(a, a)\n  nb = nand(b, b)\n  out = nand(na, nb)\n\n; XOR gate - output high when inputs differ\nmodule xor(a, b) -> out:\n  n1 = nand(a, b)\n  n2 = nand(a, n1)\n  n3 = nand(b, n1)\n  out = nand(n2, n3)\n\n; NOR gate - output high when both inputs low\nmodule nor(a, b) -> out:\n  o = or(a, b)\n  out = not(o)\n\n; XNOR gate - output high when inputs match\nmodule xnor(a, b) -> out:\n  x = xor(a, b)\n  out = not(x)\n\n; 2-to-1 multiplexer - sel=0 selects a, sel=1 selects b\nmodule mux(a, b, sel) -> out:\n  nsel = not(sel)\n  t0 = and(a, nsel)\n  t1 = and(b, sel)\n  out = or(t0, t1)\n\n; 4-bit NOT gate\nmodule not4(a:4) -> out:4:\n  out0 = not(a[0])\n  out1 = not(a[1])\n  out2 = not(a[2])\n  out3 = not(a[3])\n  out = concat(out3, out2, out1, out0)\n\n; 4-bit AND gate\nmodule and4(a:4, b:4) -> out:4:\n  out0 = and(a[0], b[0])\n  out1 = and(a[1], b[1])\n  out2 = and(a[2], b[2])\n  out3 = and(a[3], b[3])\n  out = concat(out3, out2, out1, out0)\n\n; 4-bit OR gate\nmodule or4(a:4, b:4) -> out:4:\n  out0 = or(a[0], b[0])\n  out1 = or(a[1], b[1])\n  out2 = or(a[2], b[2])\n  out3 = or(a[3], b[3])\n  out = concat(out3, out2, out1, out0)\n\n; 4-bit XOR gate\nmodule xor4(a:4, b:4) -> out:4:\n  out0 = xor(a[0], b[0])\n  out1 = xor(a[1], b[1])\n  out2 = xor(a[2], b[2])\n  out3 = xor(a[3], b[3])\n  out = concat(out3, out2, out1, out0)\n\n; 4-bit 2-to-1 multiplexer - sel=0 selects a, sel=1 selects b\nmodule mux4(sel, a:4, b:4) -> out:4:\n  out0 = mux(a[0], b[0], sel)\n  out1 = mux(a[1], b[1], sel)\n  out2 = mux(a[2], b[2], sel)\n  out3 = mux(a[3], b[3], sel)\n  out = concat(out3, out2, out1, out0)\n\n; 3-input AND gate\nmodule and3(a, b, c) -> out:\n  ab = and(a, b)\n  out = and(ab, c)\n\n; 3-input OR gate\nmodule or3(a, b, c) -> out:\n  ab = or(a, b)\n  out = or(ab, c)\n\n; 8-bit NOT gate\nmodule not8(a:8) -> out:8:\n  out0 = not(a[0])\n  out1 = not(a[1])\n  out2 = not(a[2])\n  out3 = not(a[3])\n  out4 = not(a[4])\n  out5 = not(a[5])\n  out6 = not(a[6])\n  out7 = not(a[7])\n  out = concat(out7, out6, out5, out4, out3, out2, out1, out0)\n\n; 8-bit AND gate\nmodule and8(a:8, b:8) -> out:8:\n  out0 = and(a[0], b[0])\n  out1 = and(a[1], b[1])\n  out2 = and(a[2], b[2])\n  out3 = and(a[3], b[3])\n  out4 = and(a[4], b[4])\n  out5 = and(a[5], b[5])\n  out6 = and(a[6], b[6])\n  out7 = and(a[7], b[7])\n  out = concat(out7, out6, out5, out4, out3, out2, out1, out0)\n\n; 8-bit OR gate\nmodule or8(a:8, b:8) -> out:8:\n  out0 = or(a[0], b[0])\n  out1 = or(a[1], b[1])\n  out2 = or(a[2], b[2])\n  out3 = or(a[3], b[3])\n  out4 = or(a[4], b[4])\n  out5 = or(a[5], b[5])\n  out6 = or(a[6], b[6])\n  out7 = or(a[7], b[7])\n  out = concat(out7, out6, out5, out4, out3, out2, out1, out0)\n\n; 8-bit XOR gate\nmodule xor8(a:8, b:8) -> out:8:\n  out0 = xor(a[0], b[0])\n  out1 = xor(a[1], b[1])\n  out2 = xor(a[2], b[2])\n  out3 = xor(a[3], b[3])\n  out4 = xor(a[4], b[4])\n  out5 = xor(a[5], b[5])\n  out6 = xor(a[6], b[6])\n  out7 = xor(a[7], b[7])\n  out = concat(out7, out6, out5, out4, out3, out2, out1, out0)\n",
  "wire/inc16.wire": "; 16-bit Incrementer\n; Adds 1 to a 16-bit input\n; Used for Program Counter (PC) increment in CPUs\n;\n; Implementation: Use adder16 with b=1, cin=0, only keep sum (ignore cout)\n\nmodule inc16(in:16) -> out:16:\n  ; Create constant 1 (16-bit)\n  one = 1\n\n  ; Add in + 1\n  result = adder16(in, one, 0)\n\n  ; Extract sum (ignore carry out)\n  out = result.sum\n",
  "wire/io_ctrl.wire": "; I/O Controller\n; Memory-mapped I/O at $8000-$800F\n;\n; Register Map:\n;   $8000 SERIAL_STATUS (R)   - Bit 0: RX ready, Bit 1: TX busy\n;   $8001 SERIAL_DATA   (R/W) - Read: RX byte, Write: TX byte\n;   $8002 LED_CTRL      (W)   - LED on/off control\n;   $8003 TIMER_LO      (R)   - Timer low byte (optional)\n;   $8004 TIMER_HI      (R)   - Timer high byte (optional)\n;\n; Inputs:\n;   clk        - System clock\n;   reset      - Reset signal\n;   addr:4     - Low 4 bits of address (register select)\n;   data_in:8  - Data from CPU for writes\n;   write_en   - Write enable from CPU\n;   read_en    - Read enable from CPU\n;   rx_byte:8  - Received byte from external serial\n;   rx_valid   - RX byte valid strobe\n;   tx_ack     - TX acknowledged (external consumed byte)\n;\n; Outputs:\n;   data_out:8 - Data to CPU for reads\n;   tx_byte:8  - Byte to transmit\n;   tx_valid   - TX byte valid strobe\n;   led_out    - LED state\n\nmodule io_ctrl(clk, reset, addr:4, data_in:8, write_en, read_en, rx_byte:8, rx_valid, tx_ack) -> (data_out:8, tx_byte:8, tx_valid, led_out):\n  ; Register select decoding\n  ; addr[3:0]: 0=status, 1=data, 2=led, 3=timer_lo, 4=timer_hi\n  is_reg_0 = and(and(and(not(addr[3]), not(addr[2])), not(addr[1])), not(addr[0]))  ; 0000\n  is_reg_1 = and(and(and(not(addr[3]), not(addr[2])), not(addr[1])), addr[0])       ; 0001\n  is_reg_2 = and(and(and(not(addr[3]), not(addr[2])), addr[1]), not(addr[0]))       ; 0010\n\n  ; === TX Logic ===\n  ; When CPU writes to $8001, latch the byte and set tx_pending\n  write_data_reg = and(write_en, is_reg_1)\n\n  ; TX data register - holds byte to transmit\n  tx_data = register8(data_in, write_data_reg, clk)\n  tx_byte = tx_data\n\n  ; TX valid: high for one cycle after write (registered signal)\n  ; Goes high on the clock after write_data_reg was high\n  tx_valid = dff(write_data_reg, clk)\n\n  ; TX busy flag - set on write, clear on ack\n  ; tx_busy_next = (tx_busy OR write_data_reg) AND NOT(tx_ack)\n  tx_busy_raw = dff(tx_busy_next, clk)\n  tx_busy_set = or(tx_busy_raw, write_data_reg)\n  tx_busy_next = and(tx_busy_set, not(tx_ack))\n  tx_busy = tx_busy_raw\n\n  ; === RX Logic ===\n  ; RX buffer - latches incoming byte\n  rx_buffer = register8(rx_byte, rx_valid, clk)\n\n  ; RX ready flag - set on rx_valid, clear on read\n  read_data_reg = and(read_en, is_reg_1)\n  rx_ready_raw = dff(rx_ready_next, clk)\n  rx_ready_set = or(rx_ready_raw, rx_valid)\n  rx_ready_next = and(rx_ready_set, not(read_data_reg))\n  rx_ready = rx_ready_raw\n\n  ; === LED Logic ===\n  ; LED register - written via $8002\n  write_led = and(write_en, is_reg_2)\n  led_reg = dff(led_next, clk)\n  led_next = mux(led_reg, data_in[0], write_led)\n  led_out = led_reg\n\n  ; === Status Register ===\n  ; Bit 0: RX ready, Bit 1: TX busy\n  ; Build status byte: 000000 | tx_busy | rx_ready\n  status_lo = concat(tx_busy, rx_ready)\n  status_byte = concat(0, concat(0, concat(0, concat(0, concat(0, concat(0, status_lo))))))\n\n  ; === Read Mux ===\n  ; Select output based on register address\n  ; reg 0 = status, reg 1 = rx_buffer, others = 0\n  zero8 = concat(0, concat(0, concat(0, concat(0, concat(0, concat(0, concat(0, 0)))))))\n  read_status = mux8(zero8, status_byte, is_reg_0)\n  read_data = mux8(read_status, rx_buffer, is_reg_1)\n  data_out = read_data\n",
  "wire/mux16.wire": "; 16-bit 2-to-1 Multiplexer\n; Selects between two 16-bit inputs based on selector bit\n; If sel=0: out = a\n; If sel=1: out = b\n;\n; Implementation: Use two 8-bit muxes, one for each byte\n\nmodule mux16(a:16, b:16, sel) -> out:16:\n  ; Mux low byte (bits 0-7)\n  low_out = mux8(a[0:7], b[0:7], sel)\n\n  ; Mux high byte (bits 8-15)\n  high_out = mux8(a[8:15], b[8:15], sel)\n\n  ; Concatenate high and low bytes\n  out = concat(high_out, low_out)\n",
  "wire/mux4way8.wire": "; 4-Way 8-bit Multiplexer\n; Selects one of four 8-bit inputs based on 2-bit selector\n;\n; sel:2 = 00 -> out = a\n; sel:2 = 01 -> out = b\n; sel:2 = 10 -> out = c\n; sel:2 = 11 -> out = d\n;\n; Implementation: Two-level mux tree using mux8\n\nmodule mux4way8(a:8, b:8, c:8, d:8, sel:2) -> out:8:\n  ; First level: select based on sel[0]\n  ; sel[0]=0 -> ab=a, cd=c\n  ; sel[0]=1 -> ab=b, cd=d\n  ab = mux8(a, b, sel[0])\n  cd = mux8(c, d, sel[0])\n\n  ; Second level: select based on sel[1]\n  ; sel[1]=0 -> out=ab\n  ; sel[1]=1 -> out=cd\n  out = mux8(ab, cd, sel[1])\n",
  "wire/mux8.wire": "; 8-bit 2-to-1 Multiplexer\n; Selects between two 8-bit inputs based on selector bit\n; If sel=0: out = a\n; If sel=1: out = b\n;\n; Implementation: Use 1-bit mux for each bit, concatenate results\n\nmodule mux8(a:8, b:8, sel) -> out:8:\n  ; Mux each bit\n  bit0 = mux(a[0], b[0], sel)\n  bit1 = mux(a[1], b[1], sel)\n  bit2 = mux(a[2], b[2], sel)\n  bit3 = mux(a[3], b[3], sel)\n  bit4 = mux(a[4], b[4], sel)\n  bit5 = mux(a[5], b[5], sel)\n  bit6 = mux(a[6], b[6], sel)\n  bit7 = mux(a[7], b[7], sel)\n\n  ; Concatenate bits (high to low)\n  out = concat(bit7, bit6, bit5, bit4, bit3, bit2, bit1, bit0)\n",
  "wire/mux8way8.wire": "; 8-Way 8-bit Multiplexer\n; Selects one of eight 8-bit inputs based on 3-bit selector\n;\n; sel:3 = 000 -> out = a\n; sel:3 = 001 -> out = b\n; sel:3 = 010 -> out = c\n; sel:3 = 011 -> out = d\n; sel:3 = 100 -> out = e\n; sel:3 = 101 -> out = f\n; sel:3 = 110 -> out = g\n; sel:3 = 111 -> out = h\n;\n; Implementation: Three-level mux tree using mux8\n\nmodule mux8way8(a:8, b:8, c:8, d:8, e:8, f:8, g:8, h:8, sel:3) -> out:8:\n  ; First level: select based on sel[0]\n  ab = mux8(a, b, sel[0])\n  cd = mux8(c, d, sel[0])\n  ef = mux8(e, f, sel[0])\n  gh = mux8(g, h, sel[0])\n\n  ; Second level: select based on sel[1]\n  abcd = mux8(ab, cd, sel[1])\n  efgh = mux8(ef, gh, sel[1])\n\n  ; Third level: select based on sel[2]\n  out = mux8(abcd, efgh, sel[2])\n",
  "wire/pc.wire": "; 16-bit Program Counter\n; Supports load and increment operations\n;\n; Inputs:\n;   clk     - Clock signal\n;   reset   - Reset PC to 0\n;   load    - Load PC from din\n;   inc     - Increment PC by 1\n;   din:16  - Data input for loads\n;\n; Outputs:\n;   out:16  - Current PC value\n;\n; Priority: reset > load > inc > hold\n\nmodule pc(clk, reset, load, inc, din:16) -> out:16:\n  ; Calculate next value based on operation\n  ; inc_result = current + 1\n  inc_result = inc16(out)\n\n  ; Select between hold, increment, and load\n  ; If inc=1, use inc_result, else use current (hold)\n  after_inc = mux16(out, inc_result, inc)\n\n  ; If load=1, use din, else use after_inc\n  after_load = mux16(after_inc, din, load)\n\n  ; If reset=1, use 0, else use after_load\n  zero = concat(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n  next_value = mux16(after_load, zero, reset)\n\n  ; Always enable register - we always update (hold, inc, load, or reset)\n  out = register16(next_value, 1, clk)\n",
  "wire/register16.wire": "; 16-bit CPU Components\n; Extended registers and arithmetic for CPU implementation\n\n; 16-bit register with enable\n; When en=1, latches d on rising clock edge\n; When en=0, holds previous value\nmodule register16(d:16, en, clk) -> q:16:\n  ; Split into two 8-bit registers\n  ; Lower byte (bits 0-7)\n  q_lo = register8(d[0:7], en, clk)\n  ; Upper byte (bits 8-15)\n  q_hi = register8(d[8:15], en, clk)\n  ; Concatenate back to 16-bit (high byte first)\n  q = concat(q_hi, q_lo)\n",
  "wire/registers.wire": "; Wire Standard Library - Registers\n; Sequential logic built from DFF primitives\n\n; 1-bit register with enable\n; When en=1, latches d on rising clock edge\n; When en=0, holds previous value\nmodule register(d, en, clk) -> q:\n  ; Mux between current output and new input based on enable\n  feedback = mux(q, d, en)\n  q = dff(feedback, clk)\n\n; 8-bit register with enable\nmodule register8(d:8, en, clk) -> q:8:\n  q0 = register(d[0], en, clk)\n  q1 = register(d[1], en, clk)\n  q2 = register(d[2], en, clk)\n  q3 = register(d[3], en, clk)\n  q4 = register(d[4], en, clk)\n  q5 = register(d[5], en, clk)\n  q6 = register(d[6], en, clk)\n  q7 = register(d[7], en, clk)\n  q = concat(q7, q6, q5, q4, q3, q2, q1, q0)\n\n; Simple D flip-flop wrapper (always captures)\nmodule dff_simple(d, clk) -> q:\n  q = dff(d, clk)\n\n; 4-bit D flip-flop (always captures)\nmodule dff4(d:4, clk) -> q:4:\n  q0 = dff(d[0], clk)\n  q1 = dff(d[1], clk)\n  q2 = dff(d[2], clk)\n  q3 = dff(d[3], clk)\n  q = concat(q3, q2, q1, q0)\n\n; 8-bit D flip-flop (always captures)\nmodule dff8(d:8, clk) -> q:8:\n  q0 = dff(d[0], clk)\n  q1 = dff(d[1], clk)\n  q2 = dff(d[2], clk)\n  q3 = dff(d[3], clk)\n  q4 = dff(d[4], clk)\n  q5 = dff(d[5], clk)\n  q6 = dff(d[6], clk)\n  q7 = dff(d[7], clk)\n  q = concat(q7, q6, q5, q4, q3, q2, q1, q0)\n\n; SR latch (set-reset) using NAND gates\n; Warning: S=R=1 is an invalid state\nmodule sr_latch(s, r) -> (q, qn):\n  q = nand(s, qn)\n  qn = nand(r, q)\n\n; 1-bit counter (toggle flip-flop)\nmodule counter1(en, clk) -> q:\n  next = xor(q, en)\n  q = dff(next, clk)\n\n; 8-bit counter with enable\nmodule counter8(en, clk) -> q:8:\n  ; Bit 0 toggles when enabled\n  q0 = counter1(en, clk)\n  ; Bit 1 toggles when bit 0 and enable\n  e1 = and(en, q0)\n  q1 = counter1(e1, clk)\n  ; Bit 2 toggles when bits 0,1 and enable\n  e2 = and3(en, q0, q1)\n  q2 = counter1(e2, clk)\n  ; Continue pattern...\n  c01 = and(q0, q1)\n  e3 = and3(en, c01, q2)\n  q3 = counter1(e3, clk)\n  c012 = and(c01, q2)\n  e4 = and3(en, c012, q3)\n  q4 = counter1(e4, clk)\n  c0123 = and(c012, q3)\n  e5 = and3(en, c0123, q4)\n  q5 = counter1(e5, clk)\n  c01234 = and(c0123, q4)\n  e6 = and3(en, c01234, q5)\n  q6 = counter1(e6, clk)\n  c012345 = and(c01234, q5)\n  e7 = and3(en, c012345, q6)\n  q7 = counter1(e7, clk)\n  q = concat(q7, q6, q5, q4, q3, q2, q1, q0)\n",
  "wire/system.wire": "; System Module\n; Combines CPU with address decoder for ROM-based architecture\n;\n; Memory is handled externally (in the simulator/test harness):\n;   - ROM ($C000-$FFFF): Read-only, preloaded with firmware\n;   - RAM ($0000-$3FFF): Read-write (ZP, Stack, General)\n;   - I/O ($8000-$800F): Memory-mapped I/O registers\n;\n; The system module provides chip-select signals to route\n; data_in from the appropriate memory source.\n\nmodule system(clk, reset, data_in:8) -> (addr:16, data_out:8, mem_write, halted, sel_zp, sel_stack, sel_ram, sel_io, sel_rom, a_out:8, x_out:8, y_out:8, sp_out:8, flags_out:4, pc_out:16, state_out:5):\n  ; Instantiate the CPU\n  cpu = cpu_minimal(clk, reset, data_in)\n\n  ; Instantiate the address decoder\n  decode = addr_decode(cpu.addr)\n\n  ; Pass through CPU outputs\n  addr = cpu.addr\n  data_out = cpu.data_out\n  mem_write = cpu.mem_write\n  halted = cpu.halted\n  a_out = cpu.a_out\n  x_out = cpu.x_out\n  y_out = cpu.y_out\n  sp_out = cpu.sp_out\n  flags_out = cpu.flags_out\n  pc_out = cpu.pc_out\n  state_out = cpu.state_out\n\n  ; Pass through address decoder outputs (chip selects)\n  sel_zp = decode.sel_zp\n  sel_stack = decode.sel_stack\n  sel_ram = decode.sel_ram\n  sel_io = decode.sel_io\n  sel_rom = decode.sel_rom\n"
};

export const CPU_SOURCES = ["gates.wire","arithmetic.wire","registers.wire","mux8.wire","mux4way8.wire","mux8way8.wire","mux16.wire","adder16.wire","inc16.wire","register16.wire","decoder.wire","alu8.wire","pc.wire","cpu_minimal.wire"];

export function getCpuSource(): string {
  return CPU_SOURCES.map(file => WIRE_FILES[`wire/${file}`]).join('\n');
}
