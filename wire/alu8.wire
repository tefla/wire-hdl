; 8-bit ALU for Wire CPU
; Operations: 000=ADD, 001=SUB, 010=AND, 011=OR, 100=XOR
;
; Inputs:
;   a:8    - first operand
;   b:8    - second operand
;   op:3   - operation select
;   cin    - carry in (used for ADC/SBC)
;
; Outputs:
;   result:8 - operation result
;   z        - Zero flag (result == 0)
;   n        - Negative flag (result bit 7, sign bit)
;   cout     - Carry flag (carry/borrow out from ADD/SUB)
;   vout     - Overflow flag (signed overflow for ADD/SUB)

module alu8(a:8, b:8, op:3, cin) -> (result:8, z, n, cout, vout):
  ; ========================================
  ; Compute all operations in parallel
  ; ========================================

  ; ADD: a + b + cin
  add_result = adder8(a, b, cin)

  ; SUB: a - b - !cin = a + ~b + cin
  ; For subtraction, we invert b and use cin as borrow-in
  ; When cin=1 (no borrow), we get a - b
  ; When cin=0 (borrow in), we get a - b - 1
  not_b = not8(b)
  sub_result = adder8(a, not_b, cin)

  ; Logical operations (don't use carry)
  and_result = and8(a, b)
  or_result = or8(a, b)
  xor_result = xor8(a, b)

  ; ========================================
  ; Select result based on op
  ; ========================================
  ; op: 000=ADD, 001=SUB, 010=AND, 011=OR, 100=XOR

  ; First level mux: op[0] selects within pairs
  ; mux_arith: op[0]=0 -> ADD, op[0]=1 -> SUB
  mux_arith = mux8(add_result.sum, sub_result.sum, op[0])

  ; mux_logic1: op[0]=0 -> AND, op[0]=1 -> OR
  mux_logic1 = mux8(and_result, or_result, op[0])

  ; Second level mux: op[1] selects between arithmetic and logic1
  mux_level2 = mux8(mux_arith, mux_logic1, op[1])

  ; Final mux: op[2]=1 selects XOR
  result = mux8(mux_level2, xor_result, op[2])

  ; ========================================
  ; Flag generation
  ; ========================================

  ; Zero flag: result == 0
  ; Use NOR tree to detect all zeros
  ; Group bits into pairs, NOR each pair, then AND results
  nz01 = or(result[0], result[1])
  nz23 = or(result[2], result[3])
  nz45 = or(result[4], result[5])
  nz67 = or(result[6], result[7])
  nz0123 = or(nz01, nz23)
  nz4567 = or(nz45, nz67)
  any_set = or(nz0123, nz4567)
  z = not(any_set)

  ; Negative flag: bit 7 of result (sign bit in two's complement)
  n = result[7]

  ; Carry flag: carry out from ADD or inverted borrow from SUB
  ; For ADD: direct carry out
  ; For SUB: carry out (no borrow when cout=1)
  ; Select based on op[0] (0=ADD, 1=SUB)
  cout = mux(add_result.cout, sub_result.cout, op[0])

  ; Overflow flag: signed overflow for ADD/SUB
  ; V = 1 when two operands of same sign produce result of different sign
  ; For ADD: V = (a[7] == b[7]) && (a[7] != result[7])
  ; For SUB: V = (a[7] != b[7]) && (a[7] != result[7])
  ;
  ; ADD overflow: positive + positive = negative, or negative + negative = positive
  ; SUB overflow: positive - negative = negative, or negative - positive = positive

  ; For ADD: signs are same, but result sign differs from a
  add_same_sign = xnor(a[7], b[7])              ; 1 if a and b have same sign
  add_result_diff = xor(a[7], add_result.sum[7]) ; 1 if result has different sign than a
  v_add = and(add_same_sign, add_result_diff)

  ; For SUB: signs are different (a vs b), but result sign differs from a
  sub_diff_sign = xor(a[7], b[7])               ; 1 if a and b have different signs
  sub_result_diff = xor(a[7], sub_result.sum[7]) ; 1 if result has different sign than a
  v_sub = and(sub_diff_sign, sub_result_diff)

  ; Select overflow based on operation (only valid for ADD/SUB)
  vout = mux(v_add, v_sub, op[0])
